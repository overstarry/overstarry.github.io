<!doctype html><html lang=zh dir=auto><head><meta name=generator content="Hugo 0.152.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Overstarry Site</title><meta name=keywords content="overstarry,hugo,ai assistants,mcp,blog"><meta name=description content="Overstarry 记录 AI 助理、MCP 集成与个人开发总结的 Hugo 博客"><meta name=author content="overstarry"><link rel=canonical href=https://jasminides.com/><meta name=google-site-verification content="gfdsdx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=https://jasminides.com/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://jasminides.com/img/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jasminides.com/img/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jasminides.com/img/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://jasminides.com/img/favicon/apple-touch-icon.png><link rel=mask-icon href=https://jasminides.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jasminides.com/index.xml><link rel=alternate type=application/json href=https://jasminides.com/index.json><link rel=alternate hreflang=zh href=https://jasminides.com/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-G40XG2SPQN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G40XG2SPQN")}</script><meta property="og:url" content="https://jasminides.com/"><meta property="og:site_name" content="Overstarry Site"><meta property="og:title" content="Overstarry Site"><meta property="og:description" content="Overstarry 记录 AI 助理、MCP 集成与个人开发总结的 Hugo 博客"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://jasminides.com/img/generics1-fs8.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jasminides.com/img/generics1-fs8.png"><meta name=twitter:title content="Overstarry Site"><meta name=twitter:description content="Overstarry 记录 AI 助理、MCP 集成与个人开发总结的 Hugo 博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Overstarry Site","url":"https://jasminides.com/","description":"Overstarry 记录 AI 助理、MCP 集成与个人开发总结的 Hugo 博客","logo":"https://jasminides.com/img/favicon/favicon.ico","sameAs":["https://github.com/overstarry","https://stackoverflow.com/users/8867029/overstarry"]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2240998016636586" crossorigin=anonymous></script><link rel=manifest href=https://jasminides.com/site.webmanifest></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jasminides.com/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jasminides.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://jasminides.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://jasminides.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://jasminides.com/index.xml title=rss><span>rss</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kratos 业务状态码和 HTTP 状态码分离</h2></header><div class=entry-content><p>起因 在我们使用 kratos 开发 web 应用时，由于 kratos 默认设计导致我们在自定义错误时，访问 api 时，相应的状态码是以自定义的 error code 作为 http status code 表现的。
如果我们想将 业务状态码和 HTTP 状态码分离，即所有的 http status code 都为 200，实际的业务状态码以在 response 中响应的 code 为主。
我们该如何实现呢？有 2 种方法，一种是自定义中间件将错误进行特别处理，另一种是自定义 Encoder。本篇文章主要就是介绍 Encoder 方法。
自定义 Encoder 根据我们的需要，我们需要自定义 2 个 Encoder, ErrorEncoder 和 ResponseEncoder 函数。需要的参数类型分别如下：
// ResponseEncoder with response encoder. func ResponseEncoder(en EncodeResponseFunc) ServerOption { return func(o *Server) { o.enc = en } } // ErrorEncoder with error encoder. func ErrorEncoder(en EncodeErrorFunc) ServerOption { return func(o *Server) { o.ene = en } } // EncodeResponseFunc is encode response func. type EncodeResponseFunc func(http.ResponseWriter, *http.Request, interface{}) error // EncodeErrorFunc is encode error func. type EncodeErrorFunc func(http.ResponseWriter, *http.Request, error) 1 自定义 Response 结构 定义一个 Response 的结构体
...</p></div><footer class=entry-footer><span title='2022-03-27 12:30:30 +0800 +0800'>三月 27, 2022</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Kratos 业务状态码和 HTTP 状态码分离" href=https://jasminides.com/posts/kratos-%E4%B8%9A%E5%8A%A1%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C-http-%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%A6%BB/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Apisix 使用 authing 进行认证登陆</h2></header><div class=entry-content><p>本文介绍 apisix 和 authing 对接进行 api 登陆验证的方式。
apisix 介绍 Apache APISIX 是一个动态、实时、高性能的 API 网关，提供负载均衡、动态上游、灰度发布、服务熔断、身份认证、可观测性等丰富的流量管理功能。Apache APISIX 不仅支持插件动态变更和热插拔，而且拥有众多实用的插件。Apache APISIX 的 OpenID Connect 插件支持 OpenID Connect 协议，用户可以使用该插件让 Apache APISIX 对接 Authing 服务，作为集中式认证网关部署于企业中。
authing 介绍 Authing 是国内首款以开发者为中心的全场景身份云产品，集成了所有主流身份认证协议，为企业和开发者提供完善安全的用户认证和访问管理服务。其主要功能包括：单点登录、用户分析、扫码登录、多因素认证、行为审计、风险控制、跨平台设备管理、IoT 身份认证等；兼容国际各类标准协议：OAuth2.0、OIDC、SAML、AD/LDAP、WS-Fed、JWT 等；此外还有基于函数计算可以无限制拓展 Authing 能力的 Pipeline。支持云交付和私有化部署方式，帮助企业和开发者提升生产效率。
apisix 和 authing 对接 1 登录 Authing 账号，选择自建用户应用，输入应用名称和认证地址
2 设置登陆回调 URL 和登出回调 URL 为你的 apisix 访问地址 http://127.0.0.1:9080/
3 在用户管理界面创建一个新用户，账号密码都是 user1/user1
4 在应用的配置里记录下应用的 App ID、App Secret、服务发现地址 这些信息会在 apisix 配置插件时使用。
5 安装 apisix, 具体的安装步骤就不用我们讲了，可以参考官方文档。
...</p></div><footer class=entry-footer><span title='2022-03-19 19:13:54 +0800 +0800'>三月 19, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Apisix 使用 authing 进行认证登陆" href=https://jasminides.com/posts/apisix-%E4%BD%BF%E7%94%A8-authing-%E8%BF%9B%E8%A1%8C%E8%AE%A4%E8%AF%81%E7%99%BB%E9%99%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Google_OAuth2 实践</h2></header><div class=entry-content><p>本篇文章主要介绍了 OAuth2.0 和 使用 Google 的 OAuth2.0 登录方式。
OAuth2.0 介绍 OAuth 2.0 是 OAuth 协议的下一版本，但不向下兼容 OAuth 1.0。OAuth 2.0 关注客户端开发者的简易性，同时为 Web 应用、桌面应用、手机和智能设备提供专门的认证流程。
Facebook 的新的 Graph API 只支持 OAuth 2.0，Google 在 2011 年 3 月也宣布 Google API 对 OAuth 2.0 的支持，Windows Live 也支持 OAuth 2.0。
在认证和授权的过程中涉及的三方包括： 1、服务提供方，用户使用服务提供方来存储受保护的资源，如照片，视频，联系人列表。 2、用户，存放在服务提供方的受保护的资源的拥有者。 3、客户端，要访问服务提供方资源的第三方应用，通常是网站，如提供照片打印服务的网站。在认证过程之前，客户端要向服务提供者申请客户端标识。
使用 OAuth 进行认证和授权的过程如下所示：
（A）用户打开客户端以后，客户端要求用户给予授权。 （B）用户同意给予客户端授权。 （C）客户端使用上一步获得的授权，向认证服务器申请令牌。 （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。 （E）客户端使用令牌，向资源服务器申请获取资源。 （F）资源服务器确认令牌无误，同意向客户端开放资源
Google 的 OAuth2.0 登录方式 1 进入 Google Cloud Platform 创建一个项目
2 进入 API 与服务界面，选择凭据管理，点击创建凭据，选择 OAuth 2.0 客户端 ID
...</p></div><footer class=entry-footer><span title='2022-03-13 12:56:02 +0800 +0800'>三月 13, 2022</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Google_OAuth2 实践" href=https://jasminides.com/posts/google_oauth2-%E5%AE%9E%E8%B7%B5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 模糊测试</h2></header><div class=entry-content><p>本篇文章主要讲解在 go 语言中进行模糊测试的基础知识。通过模糊测试，随机数据会针对您的测试运行，以尝试找出漏洞或导致崩溃的输入。可以通过模糊测试发现的一些漏洞示例包括 SQL 注入、buffer overflow、拒绝服务和 cross-site scripting 攻击。
想要在 go 中使用模糊测试，需要安装 go1.18beta1 以上版本，具体的安装就不过多叙述了。
1 创建项目文件夹
我们创建一个名叫 fuzz-demo 的文件夹，并在其中创建一个名叫 main.go 的文件。
2 输入代码
在 main.go 中输入如下代码：
package main import "fmt" func Reverse(s string) string { b := []byte(s) for i, j := 0, len(b)-1; i &lt; len(b)/2; i, j = i+1, j-1 { b[i], b[j] = b[j], b[i] } return string(b) } func main() { input := "quick quick brown fox jumped over the lazy dog" rev := Reverse(input) doubleRev := Reverse(rev) fmt.Printf("原来: %q\n", input) fmt.Printf("反转: %q\n", rev) fmt.Printf("再反转: %q\n", doubleRev) } Reverse 函数的作用就是对字符串进行反转。
...</p></div><footer class=entry-footer><span title='2022-03-06 10:47:15 +0800 +0800'>三月 6, 2022</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 模糊测试" href=https://jasminides.com/posts/go-%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pyroscope 持续分析平台</h2></header><div class=entry-content><p>什么是 Pyroscope? Pyroscope 是一个开源的持续分析系统，使用 Go 语言实现。服务端使用 web 页面查看，提供丰富的分析的功能，客户端提供 Go、Java、Python、Ruby、PHP、.NET 等多种语言的支持，并且支持 PUSH、PULL 两种采集方式。
Pyroscope 是一个开源的持续性能剖析平台。它能够帮你：
找出源代码中的性能问题和瓶颈 解决 CPU 利用率高的问题 理解应用程序的调用树（call tree） 追踪随一段时间内变化的情况 特性：
可以存储来自多个应用程序的多年剖析数据 你可以一次查看多年的数据或单独查看特定的事件 较低的 CPU 开销 数据压缩效率高，磁盘空间要求低 快捷的 UI 界面 部署架构图：
Pyroscope server 安装 Pyroscope server 端可以通过 docker 安装：
docker run -it -p 4040:4040 pyroscope/pyroscope:latest server
也可以在各中操作系统中直接安装。
比如 Mac:
brew install pyroscope-io/brew/pyroscope brew services start pyroscope-server 各 Liunx 发行版也方便安装
比如 ubuntu:
wget https://dl.pyroscope.io/release/pyroscope_0.10.2_amd64.deb sudo apt-get install ./pyroscope_0.10.2_amd64.deb 安装完成后，就可以通过 web 界面访问了：http://localhost:4040, 你可以通过配置文件更改监听端口以及其它一些配置项。
...</p></div><footer class=entry-footer><span title='2022-02-26 19:37:46 +0800 +0800'>二月 26, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Pyroscope 持续分析平台" href=https://jasminides.com/posts/pyroscope-%E6%8C%81%E7%BB%AD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Fsck</h2></header><div class=entry-content><p>起因 在一次使用虚拟机的时候，发现 Linux 系统进入了 Initramfs，无法正常进入系统，推测可能是系统异常关机导致磁盘文件损坏导致的。
解决 网上搜寻了一些解决方法，普遍的推荐方法是使用 Linux 命令 fsck 命令来修复磁盘文件。
费了好大劲进入另一个系统使用 fsck.ext4 -f /dev/sda1 来检查修复磁盘文件 (我所使用的 linux 系统磁盘是 ext4 格式的)。
接下来我来介绍下 fsck 的使用。
fsck fsck（file system consistency check）是 Unix 和类 Unix 系统上用于检查文件系统完整性的工具。
语法：fsck [选项] [文件系统]
常见参数：
-f 强制检查文件系统，不管是否有损坏 -p 自动修复文件系统错误 -q 做一个快速检查，以确定文件系统是否被干净地卸载。 -y 关闭互动模式，询问全部选择 y 参考 https://web.archive.org/web/20150529001726/http://www.manpagez.com/man/8/fsck/ https://zh.wikipedia.org/zh-hans/Fsck https://zh.wikipedia.org/wiki/Unix%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8</p></div><footer class=entry-footer><span title='2022-02-19 21:57:10 +0800 +0800'>二月 19, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Fsck" href=https://jasminides.com/posts/fsck/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GRPC 单向安全连接</h2></header><div class=entry-content><p>从本篇开始，我将介绍加强 gRPC 的安全性的一系列措施。本篇介绍使用 TLS 加密 gRPC 通信的第一篇文章：gRPC 单向安全连接。
TLS 协议介绍 传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。网景公司（Netscape）在 1994 年推出首版网页浏览器，网景导航者时，推出 HTTPS 协议，以 SSL 进行加密，这是 SSL 的起源。IETF 将 SSL 进行标准化，1999 年公布第一版 TLS 标准文件。随后又公布 RFC 5246（2008 年 8 月）与 RFC 6176（2011 年 3 月）。在浏览器、邮箱、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。主要的网站，如 Google、Facebook 等也以这个协议来创建安全连线，发送数据。目前已成为互联网上保密通信的工业标准。
SSL 包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用 X.509 认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。
单向安全连接 通过安全的连接进行传输数据非常重要，那么如何在 gRPC 中使用 TLS 保护 gRPC 通信呢？TLS 认证机制集成在了 gRPC 库中，这使得 gRPC 可以很方便使用 TLS 进行安全连接。 客户端和服务端之间的安全传输可以采用单向或双向的方式来实现。本文主要介绍 单向安全连接。
在单向安全连接中，只有客户端会校验服务端，以确保它所接收的数据来自预期的服务器，在建立连接时，服务端会与客户端共享其公开证书，客户端会校验收到的证书。这是通过证书授权中心完成的。证书校验完成后，客户端会使用密钥加密数据。
要启用 TLS，需要证书和密钥 (xx.key,xx.pem/xx.crt),前者是用于签名和扔着公钥，后者用于分发自签名 X.509 公钥。证书和密钥的生成这里就不过多介绍了，需要的可以自行了解。
...</p></div><footer class=entry-footer><span title='2022-02-12 22:01:09 +0800 +0800'>二月 12, 2022</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to GRPC 单向安全连接" href=https://jasminides.com/posts/grpc-%E5%8D%95%E5%90%91%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Log_and_trace</h2></header><div class=entry-content><p>本篇文章讲述了如何将 loki 和 tempo 结合进行分布式追踪。日志和 trace 结合使用的方案有很多，由于 loki 官方自带了 trace 结合的配置，不用进行过多的二次开发，所以这里采用 loki 和 tempo 结合的方案。
loki 和 tempo 是什么就不过多介绍，安装流程也省略。这里主要讲如何配置。
配置 这里我们采用普遍的方案，使用 grafana 来展示日志和 trace。
配置 loki 在 grafana , 打开数据源配置界面，新建 loki 数据源，并且配置好地址，如下图所示点击 Save & Test, 如果配置正确，则会出现 Data source connected and labels found. 标志。
配置 tempo 同配置 loki 一致，新建 grafana 数据源，选择 tempo，配置好相应的 url 数据，点击测试，出现 Data source connected and labels found. 标志，就表示配置成功。
在 tempo 配置页面的底部可以看到一个配置栏目 Trace to logs，可以选择相应的日志数据源，这里我们选择 loki.
...</p></div><footer class=entry-footer><span title='2022-01-27 17:59:52 +0800 +0800'>一月 27, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Log_and_trace" href=https://jasminides.com/posts/log_and_trace/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>K8s_Finalizers</h2></header><div class=entry-content><p>起因 在我们日常使用 k8s 中，可能会遇到这样的情况：在删除 namespace 时，往往会遇到资源没有被删除的情况，资源处于 terminating 的状态，这时我们该如何解决了，寻找到的解决方法往往是如下：
1 运行以下命令查看处于 terminating 状态的资源 (这里以 namespace 为例):
kubectl get namespaces
2 选择一个 Terminating namespace，并查看 namespace 中的 finalizer。运行以下命令：
kubectl get namespace &lt;terminating-namespace> -o yaml
得到类似这样的信息：
apiVersion: v1 kind: Namespace metadata: creationTimestamp: "2021-01-20T15:18:06Z" deletionTimestamp: "2021-01-21T02:50:02Z" name: &lt;terminating-namespace> resourceVersion: "3249493" selfLink: /api/v1/namespaces/knative-eventing uid: f300ea38-c8c2-4653-b432-b66103e412db spec: finalizers: - kubernetes status: phase: Terminating 3 导出 json 格式到 tmp.json:
...</p></div><footer class=entry-footer><span title='2022-01-23 11:21:44 +0800 +0800'>一月 23, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to K8s_Finalizers" href=https://jasminides.com/posts/k8s_finalizers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Casbin 学习 1</h2></header><div class=entry-content><p>从本篇文章开始，将由我来开始介绍访问控制框架的基础知识，本篇文章是 casbin 系列文章的第一篇，主要介绍一些 casbin 的概念和基础知识。
概述 casbin 是一个开源的访问控制框架，它的目标是让开发人员可以更加简单的控制访问控制，支持多种访问控制模型，支持多种编程语言 (各种编程语言支持的程度可以查看官网的文档)。
casbin 可以
支持自定义请求的格式，默认的请求格式为{subject, object, action}。 具有访问控制模型 model 和策略 policy 两个核心概念。 支持 RBAC 中的多层角色继承，不止主体可以有角色，资源也可以具有角色。 支持内置的超级用户 例如：root 或 administrator。超级用户可以执行任何操作而无需显式的权限声明。 支持多种内置的操作符，如 keyMatch，方便对路径式的资源进行管理，如 /foo/bar 可以映射到 /foo* Casbin 不支持的是：
身份认证 authentication（即验证用户的用户名和密码），Casbin 只负责访问控制。应该有其他专门的组件负责身份认证，然后由 Casbin 进行访问控制，二者是相互配合的关系。
管理用户列表或角色列表。Casbin 认为由项目自身来管理用户、角色列表更为合适，用户通常有他们的密码，但是 Casbin 的设计思想并不是把它作为一个存储密码的容器。而是存储 RBAC 方案中用户和角色之间的映射关系。
工作原理 在 Casbin 中，访问控制模型被抽象为基于 PERM (Policy, Effect, Request, Matcher) 的一个文件。因此，切换或升级项目的授权机制与修改配置一样简单。您可以通过组合可用的模型来定制您自己的访问控制模型。例如，您可以在一个 model 中结合 RBAC 角色和 ABAC 属性，并共享一组 policy 规则。
adapters 在 Casbin 中，策略存储作为 adapter(Casbin 的中间件) 实现。Casbin 用户可以使用 adapter 从存储中加载策略规则 (aka LoadPolicy()) 或者将策略规则保存到其中 (aka SavePolicy())。为了保持代码轻量级，我们没有把 adapter 代码放在主库中。
...</p></div><footer class=entry-footer><span title='2022-01-12 17:00:39 +0800 +0800'>一月 12, 2022</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Casbin 学习 1" href=https://jasminides.com/posts/casbin-%E5%AD%A6%E4%B9%A0-1/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jasminides.com/page/12/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://jasminides.com/page/14/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2024-now - overstarry · All rights reserved<br></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>