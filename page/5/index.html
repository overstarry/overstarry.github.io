<!doctype html><html lang=zh dir=auto><head><meta name=generator content="Hugo 0.152.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Overstarry Site</title><meta name=keywords content="overstarry,hugo,ai assistants,mcp,blog"><meta name=description content="Overstarry 记录 AI 助理、MCP 集成与个人开发总结的 Hugo 博客"><meta name=author content="overstarry"><link rel=canonical href=https://jasminides.com/><meta name=google-site-verification content="gfdsdx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=https://jasminides.com/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://jasminides.com/img/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jasminides.com/img/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jasminides.com/img/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://jasminides.com/img/favicon/apple-touch-icon.png><link rel=mask-icon href=https://jasminides.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jasminides.com/index.xml><link rel=alternate type=application/json href=https://jasminides.com/index.json><link rel=alternate hreflang=zh href=https://jasminides.com/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-G40XG2SPQN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G40XG2SPQN")}</script><meta property="og:url" content="https://jasminides.com/"><meta property="og:site_name" content="Overstarry Site"><meta property="og:title" content="Overstarry Site"><meta property="og:description" content="Overstarry 记录 AI 助理、MCP 集成与个人开发总结的 Hugo 博客"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://jasminides.com/img/generics1-fs8.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jasminides.com/img/generics1-fs8.png"><meta name=twitter:title content="Overstarry Site"><meta name=twitter:description content="Overstarry 记录 AI 助理、MCP 集成与个人开发总结的 Hugo 博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Overstarry Site","url":"https://jasminides.com/","description":"Overstarry 记录 AI 助理、MCP 集成与个人开发总结的 Hugo 博客","logo":"https://jasminides.com/img/favicon/favicon.ico","sameAs":["https://github.com/overstarry","https://stackoverflow.com/users/8867029/overstarry"]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2240998016636586" crossorigin=anonymous></script><link rel=manifest href=https://jasminides.com/site.webmanifest></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jasminides.com/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jasminides.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://jasminides.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://jasminides.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://jasminides.com/index.xml title=rss><span>rss</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>mergo 介绍</h2></header><div class=entry-content><p>前言 今天介绍一个 go 库 - mergo, mergo 用来方便的合并 struct 和 map ,可以将结构体的字段赋值到 map 中，可以将 map 的值赋值给结构体的字段。
Mergo 通过在零值字段中设置默认值来合并同类型的 struct 和 map。Mergo 不会合并未导出（私有）字段。它会递归合并任何已导出的字段。它也不会合并 map 中的结构体（因为它们无法使用 Go 反射寻址）。
Mergo 在很多知名项目中被使用，如 containerd、k8s、loki 等。
安装 使用以下命令安装 mergo : go get -u dario.cat/mergo
使用 接下来介绍 mergo 的基础使用和高级用法。
基础使用 mergo 提供了 2 个主要函数：Merge 和 Map, Mergo 用来合并 2 个相同结构的 struct 和 map, Map 用来在结构和 map 之间赋值。
例子：
package main import ( "fmt" "log" "github.com/imdario/mergo" ) type redisConfig struct { Address string Port int DB int UserName string PassWord string } var defaultConfig = redisConfig{ Address: "127.0.0.1", Port: 6379, DB: 1, UserName: "123", PassWord: "123", } func main() { var config redisConfig if err := mergo.Merge(&amp;config, defaultConfig); err != nil { log.Fatal(err) } fmt.Println("redis address: ", config.Address) fmt.Println("redis port: ", config.Port) fmt.Println("redis db: ", config.DB) fmt.Println("redis username: ", config.UserName) fmt.Println("redis password: ", config.PassWord) var m = make(map[string]interface{}) if err := mergo.Map(&amp;m, defaultConfig); err != nil { log.Fatal(err) } fmt.Println(m) } 接下来介绍一些高级用法：
...</p></div><footer class=entry-footer><span title='2023-12-16 22:15:27 +0800 +0800'>十二月 16, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to mergo 介绍" href=https://jasminides.com/posts/mergo-%E4%BB%8B%E7%BB%8D/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>conc 一个更好的 go 并发库</h2></header><div class=entry-content><p>前言 本文介绍 conc - 一个更好的 go 并发库，sourcegraph 在日常开发中使用 go 原生并发出现了问题，由此开发了 conc，相比标准并发代码更优雅，代码更少，下面展示一个例子，可以看出代码减少了许多。
type propagatedPanic struct { val any stack []byte } func main() { done := make(chan *propagatedPanic) go func() { defer func() { if v := recover(); v != nil { done &lt;- &amp;propagatedPanic{ val: v, stack: debug.Stack(), } } else { done &lt;- nil } }() doSomethingThatMightPanic() }() if val := &lt;-done; val != nil { panic(val) } } // conc func main() { var wg conc.WaitGroup wg.Go(doSomethingThatMightPanic) // panics with a nice stacktrace wg.Wait() } 安装 使用以下命令进行安装：go get github.com/sourcegraph/conc
...</p></div><footer class=entry-footer><span title='2023-12-09 23:58:07 +0800 +0800'>十二月 9, 2023</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to conc 一个更好的 go 并发库" href=https://jasminides.com/posts/conc-%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A5%BD%E7%9A%84-go-%E5%B9%B6%E5%8F%91%E5%BA%93/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kubernetes externaltrafficpolicy 简介</h2></header><div class=entry-content><p>前言 最近在使用 Kubernetes 查看 pod 日志时，发现 pod 日志显示的 ip 不是真实的请求者 ip, 而是 Node 节点的 ip。通过查阅资料发现可以通过设置 externalTrafficPolicy 来显示真实的 IP。
本文对 externaltrafficpolicy 进行一个简单的介绍。
简介 ExternalTrafficPolicy 是 Kubernetes Service 对象的一个属性，它决定了流量如何从集群外部访问 Service。有两个可选值：Cluster 和 Local。
Cluster 模式： 在 Cluster 模式下，流量将通过负载均衡器分发到 Service 的所有 Pod 上。这是传统的负载均衡方式，适用于需要水平扩展和容错的场景。负载均衡器会将流量平均分配给所有可用的 Pod，从而实现负载均衡。
Local 模式： 在 Local 模式下，流量将直接访问与请求最近的节点上运行的 Pod。这种方式避免了负载均衡器的介入，直接将流量定向到本地的 Pod 上。这样可以减少延迟，并且在负载均衡器发生故障时仍然保持可用性。
区别 两种模式有什么区别呢？
Cluster 模式 Cluster 模式是默认的模式，Kube-proxy 不管容器在哪个节点上，会公平的转发到某一个节点上，在转发时会替换掉源 ip，变成转发的上一个节点的 ip.原因是 Kube-proxy 在做转发的时候，会做一次 SNAT (source network address translation)，所以源 ip 变成了上一个节点的 ip 地址。
这个模式的优点是负载均衡比较好，缺点是由于转发，可能会有性能损耗。
Local 模式 Local 模式下，请求只转发给本机的容器，不会转发给其它节点的容器，保留了源 ip。
...</p></div><footer class=entry-footer><span title='2023-12-03 09:48:07 +0800 +0800'>十二月 3, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Kubernetes externaltrafficpolicy 简介" href=https://jasminides.com/posts/kubernetes-externaltrafficpolicy-%E7%AE%80%E4%BB%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>clarity 学习</h2></header><div class=entry-content><p>前言 最近发现了一个新的工具-clarity, clarity 是一种免费工具，用于捕获用户使用网站。安装非常简单，可以在数分钟内开始获取数据。
clarity 有以下功能特点：
热点地图：为你的所有页面自动生成。查看用户点击的位置、他们忽略的内容以及滚动的距离。 insights: 快速发现用户在何处感到灰心，并将这些问题转化为机会。 Google Analytics: 可以方便的与 Google Analytics 关联。 会话录制：观看用户如何使用你的网站。了解运行顺畅的地方、需要改进的内容，并测试新想法。 copilot: 使用由 GPT 构建的直观对话体验来理解你的分析数据。 接下来就开始介绍 clarity 的简单使用。
clarity 使用 创建项目 登录成功后，可以选择网站或者移动项目，这里选择网站，输入相应的信息。
配置代码 填完信息，需要配置相应的代码信息，可以看到有 2 种方法，一种是知名第三方平台提供的快捷配置方法另一种是手动添加代码。这里选择手动添加代码。
配置信息 根据导览，可以配置一些信息，例如与 ga 关联，屏蔽一些隐私信息。
查看数据 根据导览的指引配置完信息后，第二天再次登录系统就可以看到数据了。可以看到有 4 个主要的模块栏目：仪表盘、录制、热度地图、ga，接下来分别介绍这 4 个部分。
仪表盘 仪表盘主要就是用户在你网站上访问的整体数据的展现。
录制 录制通过名字就可以得知这个是对用户在你页面上浏览情况的录制，可以看到用户的访问的整体情况，点击了哪些元素等。
热度地图 热度地图可以看到网站的哪些页面经常被访问，被访问的页面哪些部分经常被点击。
Google Analytics Google Analytics 主要就是 ga 的数据了。
...</p></div><footer class=entry-footer><span title='2023-11-24 22:42:32 +0800 +0800'>十一月 24, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to clarity 学习" href=https://jasminides.com/posts/clarity-%E5%AD%A6%E4%B9%A0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Postgresql CTE 表达式</h2></header><div class=entry-content><p>前言 本文介绍如何使用 CTE 表达式来简化 PostgreSQL 中的一些复杂查询。那 CTE 表达式是什么呢？
CTE 介绍 在 PostgreSql 中 WITH 提供了一种方式来书写在一个大型查询中使用的辅助语句。这些语句通常被称为公共表表达式或 CTE（Common Table Expressions），它们可以被看成是定义只在一个查询中存在的临时表。在 WITH 子句中的每一个辅助语句可以是一个 SELECT、INSERT、UPDATE 或 DELETE，并且 WITH 子句本身也可以被附加到一个主语句，主语句也可以是 SELECT、INSERT、UPDATE 或 DELETE。在 PostgreSQL 中，WITH 子句提供了一种编写辅助语句的方法，以便在复杂的查询中使用。
使用 该如何创建 CTE 呢，创建 CTE 的语句如下：
WITH cte_name AS ( SELECT column1, column2, ... FROM table_name WHERE condition ... ) SELECT * FROM cte_name; 在日常查询中 CTE 用于哪些场景呢：
递归查询：CTE 表达式常用于执行递归查询。通过在 CTE 表达式中引用自身，可以简洁地实现递归操作。 复杂查询：CTE 表达式可以用于构建复杂的查询，将查询逻辑分解为更易于理解和维护的部分。每个 CTE 子查询块可以负责不同的逻辑操作，最终组合成一个完整的查询。 数据转换和重组：CTE 表达式可以用于对数据进行转换和重组。通过在不同的 CTE 子查询块中选择、过滤和连接数据，可以生成新的结果集。 递归查询 WITH 表达式如何实现递归查询呢，可以通过添加 RECURSIVE 修饰符来实现。下面是一个示例：
...</p></div><footer class=entry-footer><span title='2023-11-19 12:27:37 +0800 +0800'>十一月 19, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Postgresql CTE 表达式" href=https://jasminides.com/posts/postgresql-cte-%E8%A1%A8%E8%BE%BE%E5%BC%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 设计模式 - 策略模式</h2></header><div class=entry-content><p>今天介绍一个常见的设计模式 - 策略模式，并基于一个简单的例子来讲解。
策略模式介绍 策略模式（Strategy Pattern）是一种行为型设计模式，它将一组算法封装成独立的对象，并使它们可以互相替换。这样做的好处是，可以在运行时动态地改变对象的行为，而不需要修改使用该对象的代码。
何时可以使用策略模式呢 我们在用 GO 编程的时候经常碰到多层控制语句，一层又一层，既不优雅，也不利于后续维护。比如下述这种：
if xxx { // do something } else if xxx { // do something } else if xxx { // do something else { } 虽然按这种模式写起来简单快捷，但它也违背了面向对象的两个原则：
单一职责原则：多个控制语句，意味着拥有多种功能； 开闭原则：当要进行修改时，原有代码不可避免要被修改； 此时就可以采用策略模式来替换这类多层控制语句。
go 实现策略模式 go 语言该怎么实现策略模式呢？
在 Go 语言中，策略模式可以通过接口和函数来实现。首先，我们定义一个接口，该接口声明了算法执行的方法。然后，我们可以为每个具体的算法实现一个结构体，并实现接口中的方法。最后，我们可以在需要使用算法的地方，通过接口来调用具体的算法。
下面通过一个简单的例子来讲解策略模式，现在有这样一个场景我们现在有 2 个数据表，这 2 个数据表拥有相同的字段，都可以根据 name 来查询某个数据，我们需要根据参数的不同来决定使用哪种表进行查询，在没有使用策略模式时，我们往往使用大量的 if 来实现这个操作。 接下来由我来介绍策略模式来实现相同的操作。
先定义查询操作的接口：
type DataStrategy interface { Query(name string) } 定义 2 张表的查询 struct，并实现 DataStrategy 接口：
// table1 通过 table1 来查询 type table1 struct{} func (s *table1) Query(name string) { fmt.Println("table1 query") } // table2 type table2 struct{} func (s *table2) Query(name string) { fmt.Println("table2 query") } 再定义 Data 对象用来执行不同的策略：
...</p></div><footer class=entry-footer><span title='2023-11-11 17:29:39 +0800 +0800'>十一月 11, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 设计模式 - 策略模式" href=https://jasminides.com/posts/go-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go1.22 新循环语义</h2></header><div class=entry-content><p>前言 前段时间看到了一个提案，是关于 go for 循环的一个提案，根据提案看到了去年 rsc 在社区发出的讨论，讨论的内容主要是为了解决 for 循环变量的问题，是什么样的问题呢，常见的例子如下：
var all []*Item for _, item := range items { all = append(all, &amp;item) } 这段代码有一个问题，循环结束后，all 的内容是包含了 len(all) 个相同的指针，指针指向迭代的最后一个 item。为什么会发生这种情况呢，因为 item 变量是每个循环的而不是每次迭代的，&amp;item 每次迭代都是相同的，并且每次迭代都会被覆盖。 怎么解决呢，最简单的方法就是添加 item := item 这段代码：
var all []*Item for _, item := range items { item := item all = append(all, &amp;item) } 我在使用 Goroutine 协程时也经常遇到这种问题。这种错误已导致许多公司出现生产问题，包括 Lets Encrypt 公开记录的问题。
go 社区为了解决这个问题，打算将循环变量改为每次迭代，即隐式的添加上面的代码。由于其它一些原因，直到今年的 6 月才正式决定在 go 1.21 中添加 GOEXPERIMENT=loopvar 进行相应的尝试，并且将在 go1.22 版本中正式推出。 为了确保与现有代码的向后兼容性，新语义将仅适用于声明 go 1.22 或稍后在其 go.mod 文件中声明的模块中包含的包。
特性测试 我们通过不同版本运行的结果来对比
package main import "fmt" func main() { var prints []func() for _, v := range []int{1, 2, 3} { prints = append(prints, func() { fmt.Println(v) }) } for _, print := range prints { print() } } 没使用旧版本运行的结果是：
...</p></div><footer class=entry-footer><span title='2023-11-04 22:54:05 +0800 +0800'>十一月 4, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go1.22 新循环语义" href=https://jasminides.com/posts/go1.22-%E6%96%B0%E5%BE%AA%E7%8E%AF%E8%AF%AD%E4%B9%89/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>apisix 代理 gRPC 服务</h2></header><div class=entry-content><p>最近需要使用 apisix 来代理 gRPC 服务，本文记录一下 apisix 代理 gRPC 服务以及实践过程中遇到的一些问题。
准备 在接下来的步骤前，我们需要准备一个 gRPC 服务，我们使用 kratos 简单启动一个 gRPC 服务：
$ kratos new hellowrold $ cd helloworld $ kratos run 一个简单的 gRPC 服务就启动了，我们先直接请求 gRPC 服务看看，通过 postman 请求接口后，接口顺利返回相应的值。
接下来我们开始本篇的主要内容：apisix 代理服务。
apisix 代理 gRPC 服务 我们使用 apisix admin 接口创建 Route: upstream 的 scheme 指定为 grpc 或 grpcs,nodes 指定需要代理的服务地址。
curl http://127.0.0.1:9180/apisix/admin/routes/1 -H 'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1' -X PUT -d ' { "methods": ["POST", "GET"], "uri": "/helloworld.v1.Greeter/SayHello", "upstream": { "scheme": "grpc", "type": "roundrobin", "nodes": { "127.0.0.1:9001": 1 } } }' ...</p></div><footer class=entry-footer><span title='2023-10-20 23:04:34 +0800 +0800'>十月 20, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to apisix 代理 gRPC 服务" href=https://jasminides.com/posts/apisix-%E4%BB%A3%E7%90%86-grpc-%E6%9C%8D%E5%8A%A1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 漏洞管理工具 govulncheck</h2></header><div class=entry-content><p>前言 在 7 月份 go 团队正式推出了官方的漏洞检测工具 - govulncheck, govulncheck 默认向 https://vuln.go.dev/ 漏洞数据库请求，对数据库的请求不包含代码只有使用的包，你也可以使用 -db 来指导所使用的漏洞数据库，所使用的数据库必须实现相应的规范。
govulncheck 具有以下限制：
Govulncheck 在分析函数指针和接口调用时采用保守的方法，这可能导致一些情况下的误报或不准确的调用堆栈。 使用 reflect 进行的函数调用对于静态分析是不可见的。仅通过这些调用才能访问的易受攻击的代码将不会被报告。使用 unsafe 包可能导致漏报。 由于 Go 二进制文件不包含详细的调用信息，govulncheck 无法显示检测到的漏洞的调用图。对于二进制文件中但无法访问的代码，它可能还会报告误报。 目前还不支持 silencing 漏洞发现。请参阅 https://go.dev/issue/61211。 Govulncheck 只能读取使用 Go 1.18 及更高版本编译的二进制文件。 对于无法提取符号信息的二进制文件，govulncheck 会报告二进制文件所依赖的所有模块的漏洞。 govulncheck 架构图
govulncheck 还提供了一个可用的 API govulncheck，使开发者能够方便的将 govulncheck 集成到各种工具之中。
安装 通过以下命令安装 govulncheck:
go install golang.org/x/vuln/cmd/govulncheck@latest 使用 安装完 govulncheck 后，我们就可以使用了，进入项目路径中，执行 govulncheck ./... 。
以下是我的一个项目的输出：
Scanning your code and 508 packages across 71 dependent modules for known vulnerabilities... Vulnerability #1: GO-2023-2102 HTTP/2 rapid reset can cause excessive work in net/http More info: https://pkg.go.dev/vuln/GO-2023-2102 Standard library Found in: net/http@go1.21 Fixed in: net/http@go1.21.3 Example traces found: #1: cmd\xxx\main.go:94:19: xxx.main calls kratos.App.Run, which eventually calls http.Server.Serve #2: cmd\xxx\main.go:94:19: xxx.main calls kratos.App.Run, which eventually calls http.Server.ServeTLS Vulnerability #2: GO-2023-2043 Improper handling of special tags within script contexts in html/template More info: https://pkg.go.dev/vuln/GO-2023-2043 Standard library Found in: html/template@go1.21 Fixed in: html/template@go1.21.1 Example traces found: #1: cmd\xxx\main.go:94:19: xxx.main calls kratos.App.Run, which eventually calls template.Template.Execute #2: cmd\xxx\main.go:94:19: xxx.main calls kratos.App.Run, which eventually calls template.Template.ExecuteTemplate Vulnerability #3: GO-2023-2041 Improper handling of HTML-like comments in script contexts in html/template More info: https://pkg.go.dev/vuln/GO-2023-2041 Standard library Found in: html/template@go1.21 Fixed in: html/template@go1.21.1 Example traces found: #1: cmd\xxx\main.go:94:19: xxx.main calls kratos.App.Run, which eventually calls template.Template.Execute #2: cmd\xxx\main.go:94:19: xxx.main calls kratos.App.Run, which eventually calls template.Template.ExecuteTemplate === Informational === Found 3 vulnerabilities in packages that you import, but there are no call stacks leading to the use of these vulnerabilities. You may not need to take any action. See https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck for details. Vulnerability #1: GO-2023-2045 Memory exhaustion in QUIC connection handling in crypto/tls More info: https://pkg.go.dev/vuln/GO-2023-2045 Standard library Found in: crypto/tls@go1.21 Fixed in: crypto/tls@go1.21.1 Vulnerability #2: GO-2023-2044 Panic when processing post-handshake message on QUIC connections in crypto/tls More info: https://pkg.go.dev/vuln/GO-2023-2044 Standard library Found in: crypto/tls@go1.21 Fixed in: crypto/tls@go1.21.1 Vulnerability #3: GO-2023-1988 Improper rendering of text nodes in golang.org/x/net/html More info: https://pkg.go.dev/vuln/GO-2023-1988 Module: golang.org/x/net Found in: golang.org/x/net@v0.9.0 Fixed in: golang.org/x/net@v0.13.0 Your code is affected by 3 vulnerabilities from the Go standard library. Share feedback at https://go.dev/s/govulncheck-feedback. 输出内容分为 2 块，第一块是 Vulnerability 信息，是项目中存在的漏洞，可以看到发现了 3 个漏洞及具体的原因、触发函数、发现的版本和修复的版本。第二块是 Informational 是一些没有直接引用的包中存在的安全漏洞。
...</p></div><footer class=entry-footer><span title='2023-10-14 14:45:10 +0800 +0800'>十月 14, 2023</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 漏洞管理工具 govulncheck" href=https://jasminides.com/posts/go-%E6%BC%8F%E6%B4%9E%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-govulncheck/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go WSDL</h2></header><div class=entry-content><p>最近在实现一个功能时需要使用第三方的接口，由于第三方只提供了一个 WSDL 文件的链接，于是研究了 golang 如何解析 WSDL 并调用相应接口，本文就是介绍 WSDL 和 go 如何解析并调用。
WSDL 介绍 WSDL 是 Web Services Description Language（Web 服务描述语言）的缩写。它是一种用于描述基于 Web 服务的通信协议和消息格式的 XML 格式语言。
WSDL 被广泛用于描述 Web 服务的接口和操作。它定义了 Web 服务所提供的功能、方法、参数、数据类型以及与服务进行交互的方式。通过 WSDL 文件，客户端应用程序可以了解如何与特定的 Web 服务进行通信。
WSDL 文件通常包含以下几个主要部分：
服务定义：描述了 Web 服务的名称、命名空间和位置。 类型定义：定义了 Web 服务中使用的数据类型，例如字符串、整数等。 消息定义：定义了 Web 服务中使用的消息格式，包括输入和输出消息。 操作定义：定义了 Web 服务的操作或方法，包括输入和输出消息以及相关的参数。 绑定定义：定义了 Web 服务使用的通信协议和消息格式，例如 SOAP（Simple Object Access Protocol）和 HTTP（Hypertext Transfer Protocol）。 服务定义：将服务、绑定和端口等部分组合在一起，定义了 Web 服务的完整描述。 使用 WSDL，开发人员可以生成客户端代码，使其能够与 Web 服务进行交互。客户端可以根据 WSDL 文件了解 Web 服务的结构和可用方法，以便正确地构造请求和解析响应。
总之，WSDL 是一种用于描述 Web 服务接口和操作的语言，它提供了一种标准化的方式来描述和访问 Web 服务。
...</p></div><footer class=entry-footer><span title='2023-09-23 14:17:03 +0800 +0800'>九月 23, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go WSDL" href=https://jasminides.com/posts/go-wsdl/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jasminides.com/page/4/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://jasminides.com/page/6/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2024-now - overstarry · All rights reserved<br></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>