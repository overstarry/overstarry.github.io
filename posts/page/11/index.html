<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Overstarry Site</title>
<meta name=keywords content><meta name=description content="Posts - Overstarry Site"><meta name=author content="overstarry"><link rel=canonical href=https://jasminides.com/posts/><meta name=google-site-verification content="gfdsdx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://jasminides.com/img/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jasminides.com/img/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jasminides.com/img/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://jasminides.com/img/favicon/apple-touch-icon.png><link rel=mask-icon href=https://jasminides.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jasminides.com/posts/index.xml><link rel=alternate hreflang=zh href=https://jasminides.com/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-G40XG2SPQN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G40XG2SPQN")}</script><meta property="og:url" content="https://jasminides.com/posts/"><meta property="og:site_name" content="Overstarry Site"><meta property="og:title" content="Posts"><meta property="og:description" content="overstarry site"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://jasminides.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jasminides.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="overstarry site"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jasminides.com/posts/"}]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2240998016636586" crossorigin=anonymous></script><link rel=manifest href=/site.webmanifest></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jasminides.com/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jasminides.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://www.overstarry.com/ title=game><span>game</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://jasminides.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://jasminides.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://jasminides.com/index.xml title=rss><span>rss</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://jasminides.com/>主页</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 定时监控 Https 证书</h2></header><div class=entry-content><p>起因 最近有由于一个域名的 https 证书过期，导致某个网站出现大面积无法正常使用的故障。于是我打算使用 go 语言 来监控域名的 HTTPS 证书过期情况，来及时续期证书。
HTTPS 证书 了解证书加密体系的应该知道，TLS 证书是链式信任的，所以中间任何一个证书过期、失效都会导致整个信任链断裂，不过单纯的 Let’s Encrypt ACME 证书检测可能只关注末端证书即可，除非哪天 Let’s Encrypt 倒下…
解决 在 go 语言中，Go 在发送 HTTP 请求后，在响应体中会包含一个 TLS *tls.ConnectionState 结构体，该结构体中目前存放了服务端返回的整个证书链：
// ConnectionState records basic TLS details about the connection. type ConnectionState struct { // Version is the TLS version used by the connection (e.g. VersionTLS12). Version uint16 // HandshakeComplete is true if the handshake has concluded. HandshakeComplete bool // DidResume is true if this connection was successfully resumed from a // previous session with a session ticket or similar mechanism. DidResume bool // CipherSuite is the cipher suite negotiated for the connection (e.g. // TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_AES_128_GCM_SHA256). CipherSuite uint16 // NegotiatedProtocol is the application protocol negotiated with ALPN. NegotiatedProtocol string // NegotiatedProtocolIsMutual used to indicate a mutual NPN negotiation. // // Deprecated: this value is always true. NegotiatedProtocolIsMutual bool // ServerName is the value of the Server Name Indication extension sent by // the client. It's available both on the server and on the client side. ServerName string // PeerCertificates are the parsed certificates sent by the peer, in the // order in which they were sent. The first element is the leaf certificate // that the connection is verified against. // // On the client side, it can't be empty. On the server side, it can be // empty if Config.ClientAuth is not RequireAnyClientCert or // RequireAndVerifyClientCert. PeerCertificates []*x509.Certificate // VerifiedChains is a list of one or more chains where the first element is // PeerCertificates[0] and the last element is from Config.RootCAs (on the // client side) or Config.ClientCAs (on the server side). // // On the client side, it's set if Config.InsecureSkipVerify is false. On // the server side, it's set if Config.ClientAuth is VerifyClientCertIfGiven // (and the peer provided a certificate) or RequireAndVerifyClientCert. VerifiedChains [][]*x509.Certificate // SignedCertificateTimestamps is a list of SCTs provided by the peer // through the TLS handshake for the leaf certificate, if any. SignedCertificateTimestamps [][]byte // OCSPResponse is a stapled Online Certificate Status Protocol (OCSP) // response provided by the peer for the leaf certificate, if any. OCSPResponse []byte // TLSUnique contains the "tls-unique" channel binding value (see RFC 5929, // Section 3). This value will be nil for TLS 1.3 connections and for all // resumed connections. // // Deprecated: there are conditions in which this value might not be unique // to a connection. See the Security Considerations sections of RFC 5705 and // RFC 7627, and https://mitls.org/pages/attacks/3SHAKE#channelbindings. TLSUnique []byte // ekm is a closure exposed via ExportKeyingMaterial. ekm func(label string, context []byte, length int) ([]byte, error) } 可以看到 PeerCertificates 包含了所有的证书，我们只只要遍历 PeerCertificates，根据 NotBefore, NotAfter 字段就能进行是否过期的判断
...</p></div><footer class=entry-footer><span title='2022-06-11 14:29:57 +0800 +0800'>六月 11, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 定时监控 Https 证书" href=https://jasminides.com/posts/go%E5%AE%9A%E6%97%B6%E7%9B%91%E6%8E%A7https%E8%AF%81%E4%B9%A6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 并发 Sync.Once 解析</h2></header><div class=entry-content><p>在 go 语言中我们可以使用 sync.Once 对象来实现函数方法只执行一次的功能。
简单代码示例 package main import ( "fmt" "sync" ) func main() { var ( o sync.Once wg sync.WaitGroup ) for i := 0; i &lt; 10; i++ { wg.Add(1) go func(i int) { defer wg.Done() o.Do(func() { fmt.Printf("hello %d\n", i) }) }(i) } wg.Wait() } 输出：
hello 9 不使用 Sync.Once 的结果如下：
hello 9 hello 4 hello 0 hello 1 hello 2 hello 3 hello 6 hello 5 hello 7 hello 8 可以看到，在使用 sync.Once 的情况下，只执行一次函数。
...</p></div><footer class=entry-footer><span title='2022-06-03 22:57:38 +0800 +0800'>六月 3, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 并发 Sync.Once 解析" href=https://jasminides.com/posts/go%E5%B9%B6%E5%8F%91sync.once%E8%A7%A3%E6%9E%90/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 截取视频某一帧图片</h2></header><div class=entry-content><p>前言 最近遇到一个需求，需要截取视频的某一帧图片作为视频封面。我搜寻了相关资料，在 go 语言端常见的有两种做法，1）使用 opencv 的 go 绑定库，2）使用 ffmpeg 的 go 绑定库。
这里我打算使用第二种方法，使用 ffmpeg 的 go 绑定库。
ffmpeg 介绍 FFmpeg 是一个开源免费跨平台的视频和音频流方案，属于自由软件，采用 LGPL 或 GPL 许可证（依据你选择的组件）。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库 libavcodec，为了保证高可移植性和编解码质量，libavcodec 里很多 codec 都是从头开发的。
FFmpeg 在 Linux 平台下开发，但它同样也可以在其它操作系统环境中编译运行，包括 Windows、Mac OS X 等。
FFmpeg 项目由以下几部分组成:
FFMpeg 视频文件转换命令行工具，也支持经过实时电视卡抓取和编码成视频文件。
FFServer 基于 HTTP(RTSP 正在开发中) 用于实时广播的多媒体服务器，也支持时间平移.
FFplay 用 SDL 和 FFmpeg 库开发的一个简单的媒体播放器.
libavcodec 一个包含了所有 FFmpeg 音视频编解码器的库。为了保证最优性能和高可复用性，大多数编解码器从头开发的.
libavformat 一个包含了所有的普通音视格式的解析器和产生器的库
解决 1 安装 ffmpeg
浏览器访问 https://ffbinaries.com/downloads 根据你的系统安装 ffmpeg
2 安装 ffmpeg 的 go 绑定库
...</p></div><footer class=entry-footer><span title='2022-05-28 22:28:19 +0800 +0800'>五月 28, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 截取视频某一帧图片" href=https://jasminides.com/posts/go%E6%88%AA%E5%8F%96%E8%A7%86%E9%A2%91%E6%9F%90%E4%B8%80%E5%B8%A7%E5%9B%BE%E7%89%87/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go errgroup</h2></header><div class=entry-content><p>我们知道在 go 语言中很容易开启携程进行并发任务，但是如何处理并发过程中的错误是非常棘手的，接下来我就来介绍 errgroup 的用法。
errgroup errgroup 包里主要是一个结构体和相应的方法，它可以让你在并发任务中处理错误。
type Group struct { // context 的 cancel 方法 cancel func() // 复用 WaitGroup wg sync.WaitGroup sem chan token // 用来保证只会接受一次错误 errOnce sync.Once // 保存第一个返回的错误 err error } func WithContext(ctx context.Context) (*Group, context.Context) func (g *Group) done() func (g *Group) Wait() error func (g *Group) Go(f func() error) func (g *Group) TryGo(f func() error) bool func (g *Group) SetLimit(n int) 通过 WithContext 可以创建一个可以取消的 Group，当然除此之外也可以零值的 Group 也可以直接使用，但是出错之后就不会取消其他的 goroutine 了。Go 方法 传入一个函数参数，会启动一个 goroutine 处理。
Wait 类似 WaitGroup 的 Wait 方法，等待所有的 goroutine 结束后退出，返回的错误是一个出错的 err。
TryGo 是和 SetLimit 配套的，只有当 group 中的 goroutines 数量小于配置的数量时，才会在 goroutine 中调用函数。TryGo 用来判断 goroutine 是否启动。
...</p></div><footer class=entry-footer><span title='2022-05-21 22:13:36 +0800 +0800'>五月 21, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go errgroup" href=https://jasminides.com/posts/go-errgroup/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>应用内存升高原因排查</h2></header><div class=entry-content><p>起因 最近一个部署了 go 应用的服务器出现了 OOM 的现象，内存占用过高。
原因 通过 Pyroscope 分析得出是因为 Minio 的 go sdk 中的 PutObject 函数占用了大量的内存。Pyroscope 是什么，前面的文章已经介绍过了，这里就不过多介绍了。
接下来我们通过查看相关的源码来查看是什么原因。
// PutObject creates an object in a bucket. // // You must have WRITE permissions on a bucket to create an object. // // - For size smaller than 16MiB PutObject automatically does a // single atomic PUT operation. // // - For size larger than 16MiB PutObject automatically does a // multipart upload operation. // // - For size input as -1 PutObject does a multipart Put operation // until input stream reaches EOF. Maximum object size that can // be uploaded through this operation will be 5TiB. // // WARNING: Passing down '-1' will use memory and these cannot // be reused for best outcomes for PutObject(), pass the size always. // // NOTE: Upon errors during upload multipart operation is entirely aborted. func (c *Client) PutObject(ctx context.Context, bucketName, objectName string, reader io.Reader, objectSize int64, opts PutObjectOptions, ) (info UploadInfo, err error) { if objectSize &lt; 0 && opts.DisableMultipart { return UploadInfo{}, errors.New("object size must be provided with disable multipart upload") } err = opts.validate() if err != nil { return UploadInfo{}, err } return c.putObjectCommon(ctx, bucketName, objectName, reader, objectSize, opts) } 从方法的注释可以看出，当传递的大小为 -1 时，会进行多次 put 操作，直到输入流结束。多次 put 操作的最大大小为 5TiB，并且不能重用内存，导致占用大量内存。
...</p></div><footer class=entry-footer><span title='2022-05-14 15:50:16 +0800 +0800'>五月 14, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to 应用内存升高原因排查" href=https://jasminides.com/posts/%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E5%8D%87%E9%AB%98%E5%8E%9F%E5%9B%A0%E6%8E%92%E6%9F%A5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>多平台博客发布工具 openwrite 使用</h2></header><div class=entry-content><p>介绍 OpenWrite 是一款便捷的多平台博客发布工具，可以在 OpenWrite 编写 markdown 文档，然后发布到其他博客平台，目前已经支持 CSDN、SegmentFault、掘金、博客园、简书等知名平台。
使用 注册 进入 http://admin.openwrite.cn/, 注册并登陆账号。
安装浏览器插件 第一步需要安装浏览器插件，根据这个链接教程安装，只有安装了插件，才能配置分发的平台。根据对插件的源码的分析，插件是通过 cookie、storage 等浏览器数据进行认证登陆的。此插件还包括模拟写作和 mackdown 编辑器。
认证配置渠道 安装完插件后，点击渠道管理，可以看到可配置的平台，支持多个平台。相应的平台如果没有登陆则显示未登陆，这时需要你登陆相应的平台。登陆平台后，点击认证，即可配置渠道。
这里以掘金为例，认证成功后，可以进行相应的配置，配置文章分类和标题。
发布文章 点击文章管理界面，添加文章，添加文章后，可以选择配置的平台，并发布到相应的平台。
普通用户一个月只有 10 次机会，一个平台占用一次机会。</p></div><footer class=entry-footer><span title='2022-05-07 21:47:52 +0800 +0800'>五月 7, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to 多平台博客发布工具 openwrite 使用" href=https://jasminides.com/posts/%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83%E5%B7%A5%E5%85%B7openwrite%E4%BD%BF%E7%94%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Buf 初入门 2</h2></header><div class=entry-content><p>上文讲了 Buf lint 命令的基础方法，本文将介绍 Buf lint 命令的一些常用配置。
如果你的项目中没有 buf.yaml 配置文件，Buf lint 会提供一个默认的配置文件，默认内容如下：
version: v1 lint: use: - DEFAULT except: - FILE_LOWER_SNAKE_CASE ignore: - bat - ban/ban.proto ignore_only: ENUM_PASCAL_CASE: - foo/foo.proto - bar BASIC: - foo enum_zero_value_suffix: _UNSPECIFIED rpc_allow_same_request_response: false rpc_allow_google_protobuf_empty_requests: false rpc_allow_google_protobuf_empty_responses: false service_suffix: Service allow_comment_ignores: true 配置选项 接下来开始介绍 Buf lint 命令的配置选项。
use use 选项配置 lint 的类别，不同类别有相应的规则，有多种类别：DEFAULT、FILE_LOWER_SNAKE_CASE、BASIC 等。默认是 DEFAULT 类别。
except except 选项配置 lint 不使用的类别。
下面的配置，显示使用 DEFAULT 类别，但是不使用 ENUM_NO_ALLOW_ALIAS ,BASIC 类别中的规则。
version: v1 lint: use: - DEFAULT except: - ENUM_NO_ALLOW_ALIAS - BASIC ignore ignore 选项指定忽略的文件，可以是文件名，也可以是目录，注意路径是要相对于 buf.yaml 文件的。
...</p></div><footer class=entry-footer><span title='2022-05-04 19:19:58 +0800 +0800'>五月 4, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Buf 初入门 2" href=https://jasminides.com/posts/buf%E5%88%9D%E5%85%A5%E9%97%A82/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Buf 初入门 1</h2></header><div class=entry-content><p>Buf 的目标是将 API 开发转向模式驱动的范式，从而为未来铺平道路，使 API 以服务所有者和客户可以依赖的方式定义。
与简单地暴露 REST/JSON 服务相比，使用 IDL 来定义 API 有很多好处，今天，Protobuf 是业界最稳定、最广泛采用的 IDL。但就目前的情况来看，使用 Protobuf 比使用 JSON 作为数据传输格式要困难得多。
Buf 正在建立工具，使 Protobuf 对服务所有者和客户来说是可靠和友好的，同时保持它在技术上的明显优势。您的组织不需要重新发明轮子来高效地创建、维护和使用 Protobuf API。我们将为您处理您的 Protobuf 管理策略，因此您可以专注于重要的事情。
本篇文章是讲述 buf 使用的第一篇文章，主要讲解使用 buf 定义 proto 文件的 lint 规则。统一的 lint 规则，可以让个人或团队定义的 API 保持一致。
lint 1 创建 buf.yaml 文件 使用 buf mod init 命令创建 buf.yaml 文件。
version: v1 breaking: use: - FILE lint: use: - DEFAULT 使用默认 lint 规则。
2 运行 lint 命令
使用 buf lint 命令运行 lint。
...</p></div><footer class=entry-footer><span title='2022-04-23 19:25:43 +0800 +0800'>四月 23, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Buf 初入门 1" href=https://jasminides.com/posts/buf%E5%88%9D%E5%85%A5%E9%97%A81/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 统计代码测试覆盖率</h2></header><div class=entry-content><p>今天来讲一讲如何统计 go 代码的测试覆盖率，主要是 cover 命令。
cover 基本用法 1 先简单写个函数和相应的测试，代码如下：
func Max(a, b int) int { if a > b { return a } return b } 这个函数就是简单的比较大小，如果 a > b，返回 a，否则返回 b。
测试代码如下
package main import "testing" func TestMax(t *testing.T) { type args struct { a int b int } tests := []struct { name string args args want int }{ { name: "a is larger than b", args: args{ a: 2, b: 1, }, want: 2, }, { name: "b is larger than a", args: args{ a: 1, b: 2, }, want: 2, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := Max(tt.args.a, tt.args.b); got != tt.want { t.Errorf("Max() = %v, want %v", got, tt.want) } }) } } 2 go test -cover 能够统计出代码测试的覆盖率，这是一种比统计函数是否被调用更强悍的手法。我们执行这个命令。输出如下：
...</p></div><footer class=entry-footer><span title='2022-04-16 22:08:49 +0800 +0800'>四月 16, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 统计代码测试覆盖率" href=https://jasminides.com/posts/go%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kswapd0 is consuming a lot of CPU.</h2></header><div class=entry-content><p>Issue Recently, a Linux server has been experiencing high CPU usage, causing the server to become unresponsive and other processes to fail to execute smoothly. By using the top command to check resource usage, it can be seen that the kswapd0 process is consuming a large amount of CPU resources.
Cause and solution Based on my research, the kswapd0 process is responsible for managing virtual memory.
Typically, a Linux system comprises RAM, swap, and EXT4 components. The EXT4 partition is used to store regular files and can be created on either an HDD or an SSD, though it is relatively slower compared to RAM. RAM, commonly referred to as memory, is used for high-speed program execution. The swap partition, on the other hand, is used as additional virtual memory and is normally allocated on physical disks, especially on machines with limited physical RAM.
...</p></div><footer class=entry-footer><span title='2022-04-09 16:17:19 +0800 +0800'>四月 9, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Kswapd0 is consuming a lot of CPU." href=https://jasminides.com/posts/kswapd0_consumes_a_lot_of_cpu/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jasminides.com/posts/page/10/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://jasminides.com/posts/page/12/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2024 - overstarry · All rights reserved<br></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>