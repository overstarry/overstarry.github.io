<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Overstarry Site</title><meta name=keywords content><meta name=description content="Posts - Overstarry Site"><meta name=author content="overstarry"><link rel=canonical href=https://jasminides.com/posts/><meta name=google-site-verification content="gfdsdx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://jasminides.com/img/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jasminides.com/img/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jasminides.com/img/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://jasminides.com/img/favicon/apple-touch-icon.png><link rel=mask-icon href=https://jasminides.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jasminides.com/posts/index.xml><link rel=alternate hreflang=zh href=https://jasminides.com/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-G40XG2SPQN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G40XG2SPQN")}</script><meta property="og:url" content="https://jasminides.com/posts/"><meta property="og:site_name" content="Overstarry Site"><meta property="og:title" content="Posts"><meta property="og:description" content="overstarry site"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://jasminides.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jasminides.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="overstarry site"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jasminides.com/posts/"}]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2240998016636586" crossorigin=anonymous></script><link rel=manifest href=/site.webmanifest></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jasminides.com/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jasminides.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://www.overstarry.com/ title=game><span>game</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://pokemon.jasminides.com/ title=pokemon><span>pokemon</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://jasminides.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://jasminides.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://jasminides.com/index.xml title=rss><span>rss</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://jasminides.com/>主页</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Apisix Docker 部署网站重定向端口错误问题</h2></header><div class=entry-content><p>前言 前段时间在使用 apisix 添加路由时，需要将 http 转为 https, 在配置 http_to_https 后，访问相应网址时发现 https 的端口不是我们所配置的默认端口 443，而是 9443 端口。
可以看到访问 http://localhost 会跳转至错误的地址：https://localhost:9443/ ,正确的地址应该是 https://localhost，这是怎么回事呢？
分析 接下来我来简单对问题进行简单分析。
我是采用 docker 的方式部署的 apisix，这是我们的配置文件：
version: "3" services: apisix-dashboard: image: apache/apisix-dashboard:3.0.0-alpine restart: always volumes: - ./dashboard_conf/conf.yaml:/usr/local/apisix-dashboard/conf/conf.yaml ports: - "9000:9000" networks: apisix: apisix: image: apache/apisix:${APISIX_IMAGE_TAG:-3.2.0-debian} restart: always volumes: - ./apisix_conf/config.yaml:/usr/local/apisix/conf/config.yaml:ro depends_on: - etcd ##network_mode: host ports: - "9180:9180/tcp" - "80:9080/tcp" - "9091:9091/tcp" - "443:9443/tcp" - "9092:9092/tcp" networks: apisix: etcd: image: bitnami/etcd:3.4.15 restart: always volumes: - etcd_data:/bitnami/etcd environment: ETCD_ENABLE_V2: "true" ALLOW_NONE_AUTHENTICATION: "yes" ETCD_ADVERTISE_CLIENT_URLS: "http://etcd:2379" ETCD_LISTEN_CLIENT_URLS: "http://0.0.0.0:2379" ports: - "2379:2379/tcp" networks: apisix: web1: image: nginx:1.19.0-alpine restart: always volumes: - ./upstream/web1.conf:/etc/nginx/nginx.conf ports: - "9081:80/tcp" environment: - NGINX_PORT=80 networks: apisix: networks: apisix: driver: bridge volumes: etcd_data: driver: local 可以看到我们将 apisix 容器的 http 端口和 https 端口映射为 80 和 443，按照常理来说，http_to_https 后的端口应该也是 443 端口才对。我猜测重定向时，apisix 还是采用配置文件中设定的 https 端口才导致跳转的 url 端口错误。
...</p></div><footer class=entry-footer><span title='2023-05-13 22:02:10 +0800 +0800'>五月 13, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Apisix Docker 部署网站重定向端口错误问题" href=https://jasminides.com/posts/apisix-docker%E9%83%A8%E7%BD%B2%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go wasi</h2></header><div class=entry-content><p>WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。
Go 从 1.11 版本就开始支持将 Go 源码编译为 wasm 二进制文件，并在支持 wasm 的浏览器环境中运行。
不过 WebAssembly 绝不仅仅被设计为仅限于在 Web 浏览器中运行，核心的 WebAssembly 语言是独立于其周围环境的，WebAssembly 完全可以通过 API 与外部世界互动。在 Web 上，它自然使用浏览器提供的现有 Web API。然而，在浏览器之外，之前还没有一套标准的 API 可以让 WebAssembly 程序使用。这使得创建真正可移植的非 Web WebAssembly 程序变得困难。WebAssembly System Interface(WASI) 是一个填补这一空白的倡议，它有一套干净的 API，可以由多个引擎在多个平台上实现，并且不依赖于浏览器的功能（尽管它们仍然可以在浏览器中运行）。
Go 1.21 将增加对 WASI 的支持，初期先支持 WASI Preview1 版本，之后会支持 WASI Preview2 版本，直至最终 WASI API 版本发布！
go 编译支持 wasi 的程序 怎么样才能编译支持 wasi 的程序呢？我们可以使用 GOOS=wasip1 GOARCH=wasm 将 Go 源码编译为支持 WASI 的 wasm 程序。下面是一个例子：
...</p></div><footer class=entry-footer><span title='2023-05-02 15:41:33 +0800 +0800'>五月 2, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go wasi" href=https://jasminides.com/posts/go-wasi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 实现简单反向代理</h2></header><div class=entry-content><p>前言 说起反向代理，大家应该都不陌生，是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。常见的反向代理有 Nginx,HAProxy,Apisix 等。
接下来介绍如何使用 go 实现一个反向代理服务器。
golang 实现 使用 golang 实现反向代理非常简单，标准库 net/http/httputil 提供了反向代理的方法可以让我们方便的实现反向代理，使我们可以很快的实现一个简单的反向代理服务器。
package main import ( "log" "net/http" "net/http/httputil" "net/url" ) func NewProxy(targetHost string) (*httputil.ReverseProxy, error) { url, err := url.Parse(targetHost) if err != nil { return nil, err } return httputil.NewSingleHostReverseProxy(url), nil } func ProxyRequestHandler(proxy *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) { return func(w http.ResponseWriter, r *http.Request) { proxy.ServeHTTP(w, r) } } func main() { proxy, err := NewProxy("https://overstarry.vip") if err != nil { panic(err) } http.HandleFunc("/", ProxyRequestHandler(proxy)) log.Fatal(http.ListenAndServe(":8080", nil)) } 这段代码将到达我们代理服务器的任何请求都会被代理到 https://overstarry.vip。我们运行代码，访问网站，发现 403 Forbidden 好像请求被拦截了，应该是源网站进行了请求校验，这该怎么处理呢？通过查阅资料得知，我们需要将 host 传递过去，修改后的代码如下：
package main import ( "log" "net/http" "net/http/httputil" "net/url" ) func NewProxy(targetHost string) (*httputil.ReverseProxy, error) { url, err := url.Parse(targetHost) if err != nil { return nil, err } return httputil.NewSingleHostReverseProxy(url), nil } func ProxyRequestHandler(proxy *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) { return func(w http.ResponseWriter, r *http.Request) { r.Host = "overstarry.vip" proxy.ServeHTTP(w, r) } } func main() { proxy, err := NewProxy("https://overstarry.vip") if err != nil { panic(err) } http.HandleFunc("/", ProxyRequestHandler(proxy)) log.Fatal(http.ListenAndServe(":8080", nil)) } 现在运行代码即可正常访问了。
...</p></div><footer class=entry-footer><span title='2023-04-08 17:12:41 +0800 +0800'>四月 8, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 实现简单反向代理" href=https://jasminides.com/posts/go%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CertificateManager 使用 dns 授权申请证书 -- gcloud 方式</h2></header><div class=entry-content><p>本文讲解如何使用 dns 授权方式申请 google cloud 证书，通过查阅官方文档可以得知可以使用 gcloud 和 Certificate Manager API 来申请证书，本文使用 gcloud 命令行工具来执行步骤。
创建 DNS 授权 第一步是创建 DNS 授权，使用以下命令来创建：
gcloud certificate-manager dns-authorizations create AUTHORIZATION_NAME \ --domain="DOMAIN_NAME" gcloud certificate-manager dns-authorizations describe AUTHORIZATION_NAME 需要将 AUTHORIZATION_NAME 和 DOMAIN_NAME 分别替换为 dns 授权的名称和相应的域名。
先创建 dns 授权然后查看授权的详细信息
gcloud certificate-manager dns-authorizations create overstarry --domain="overstarry.vip" gcloud certificate-manager dns-authorizations describe overstarry 根据返回的 cname 信息，需要到相应的域名解析中添加 cname 记录。
创建引用 DNS 授权的 Google 管理的证书 接下来 创建引用 DNS 授权的 Google 管理的证书，使用以下命令创建：
...</p></div><footer class=entry-footer><span title='2023-03-29 10:42:59 +0800 +0800'>三月 29, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to CertificateManager 使用 dns 授权申请证书 -- gcloud 方式" href=https://jasminides.com/posts/certificatemanager%E4%BD%BF%E7%94%A8dns%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E8%AF%81%E4%B9%A6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Google Cloud 清除 CDN 缓存</h2></header><div class=entry-content><p>最近在研究使用 google cloud 的 cdn 服务，本文就来讲解如何清除 cdn 的缓存。
本文介绍了几种清除 cdn 缓存的方法。
google cloud console 清除 第一种也是最简单的，就是直接从 google cloud console 后台进行操作，我们打开 console 后台，选择网络服务，点击负载均衡界面，选择我们要清除的 cdn 缓存所使用的负载均衡器，点击缓存页面， 输入想要 cdn 节点清除的路径即可。过了一会，就可以看到操作成功，相应的文件已经失效。 Google Cloud CLI 命令 第二种方法是使用 Google Cloud CLI 使 cdn 缓存文件失效。
Google Cloud CLI 安装 该怎么安装 Google Cloud CLI 呢，有 2 个办法：1) 直接下载安装二进制文件 2) 使用 Cloud Shell. 本文是使用 Cloud Shell 进行的操作。
使缓存内容失效 1 使用 gcloud compute url-maps list 列出目前所使用的负载均衡器
...</p></div><footer class=entry-footer><span title='2023-03-25 14:33:23 +0800 +0800'>三月 25, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Google Cloud 清除 CDN 缓存" href=https://jasminides.com/posts/googlecloud%E6%B8%85%E9%99%A4cdn%E7%BC%93%E5%AD%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>apisix 数据备份</h2></header><div class=entry-content><p>今天我来讲讲如何备份 apisix 的数据，主要是路由、服务、上游等数据。本文中的 apisix 版本为 apisix 3.1.0 版本。
接下来由我来介绍几种备份方法。
dashboard 导出备份 介绍的第一种方法是使用 apisix dashboard 进行数据导出，但这种方法有许多缺陷，只能导出 route 数据，其他服务、ssl 数据都不能导出，而且新版本 (3.0+)dashboard 导出的路由不包含上游服务的数据，不方便进行快速的路由迁移复制 (我猜测可能是害怕上游服务信息不一致导致路由错误)。
接下来就来介绍如何进行导入导出。
1 我们打开 dashboard
2 选择要导出的路由，点击 export openapi
3 在新的 apisix dashboard 导入刚刚导出的 openapi 文件并填写相应的信息，导入成功后就可以看到导入的路由信息，相应路由的服务需要补充填写。
根据 admin api 编写相应的脚本 apisix 提供了各种 route、service 的 admin api 数据接口，我们可以根据官方提供的接口编写相应的脚本。
使用 etcd 备份方案 由于 apisix 默认采用 etcd 进行数据存储，我们可以备份 etcd 数据，到新的 apisix 集群导入备份的数据。
由于我对 etcd 的运维不太熟悉，想要了解 etcd 备份快照，可以查看这条链接。
...</p></div><footer class=entry-footer><span title='2023-03-18 23:17:24 +0800 +0800'>三月 18, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to apisix 数据备份" href=https://jasminides.com/posts/apisix%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>apisix 如何添加自定义插件</h2></header><div class=entry-content><p>最近在研究 apisix 插件，想要研究插件的执行流程，为了了解插件的具体运行流程，查看了几种方法来调试:1. inspect plugin 2. 自定义插件调试 等等。
本文介绍了添加启用自定义插件。
简单修改插件 最近在研究 apisix 的 proxy-cache 插件，本文就以 proxy-cache 插件为例子来讲解 docker 环境下如何自定义插件。
我们先从 apisix 官方 git 库拷贝 proxy-cache 插件代码到本地文件夹。我们对插件的内容进行修改删除，并将插件名称修改为 proxy-cache2, 修改后的插件文件列表如下：
删除了内存缓存的相关内容，只保留了磁盘缓存的内容，并添加了一些日志记录好了解整个插件的整体流程。
apisix 添加自定义插件 接下来需要给 apisix 添加我们修改的 proxy-cache2 插件，通过查看容器的目录，我们需要将插件挂载到 /usr/local/apisix/apisix/plugins 目录下，我们修改 docker-compose 文件：
version: "3" services: apisix: image: apache/apisix:${APISIX_IMAGE_TAG:-3.2.0-debian} restart: always volumes: - ./apisix_conf/config.yaml:/usr/local/apisix/conf/config.yaml:ro - ./apisix/plugins/proxy-cache2:/usr/local/apisix/apisix/plugins/proxy-cache2 - ./apisix_log://usr/local/apisix/logs depends_on: - etcd ##network_mode: host ports: - "9180:9180/tcp" - "9080:9080/tcp" - "9091:9091/tcp" - "9443:9443/tcp" - "9092:9092/tcp" networks: apisix: 我们添加 ./apisix/plugins/proxy-cache2:/usr/local/apisix/apisix/plugins/proxy-cache2 将本地的插件目录挂载进行容器中，重启 apisix。
...</p></div><footer class=entry-footer><span title='2023-03-12 11:40:27 +0800 +0800'>三月 12, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to apisix 如何添加自定义插件" href=https://jasminides.com/posts/apisix%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>apisix 根据请求 host 访问不同路径</h2></header><div class=entry-content><p>前言 最近有一个需求，需要配置一个路由，这个路由是子域名形式的，域名类似 xx.apps.overstarry.vip，我们需要根据子域名中的 xx 内容来请求同一个对象存储中不同的文件。
这个需求之前处理过，那时采用了 nginx 来处理主要路径的逻辑，apisix 直接请求 nginx 服务，也就是大概这样的一种结构：apisix -> nginx -> oss。这次同样的需求，我决定采用 2 层结构，去除中间的 nginx 层，由 apisix 直接访问 oss 服务。
接下来我就来讲述处理的过程。
过程 使用 proxy-rewrite 处理这个需求，我第一反应是使用 proxy-rewrite 插件来处理，我使用 regex_uri 字段来进行正则替换匹配，添加的插件内容如下：
"proxy-rewrite": { "regex_uri": [ "^(.*).apps0.overstarry.vip(.*)$", "/$1/production$2" ] } 配置完后，请求了几次，发现没有请求成功，通过查看日志发现请求到了奇怪的地址。又仔细的研究了一会，发现是我理解错误了，proxy_rewrite 是根据 uri 进行正则匹配的，没有根据 host 匹配的选项，前面填写的那些是根本不会匹配成功的。
serverless proxy-rewrite 插件不能实现我们的需求，我又查看了 issue 列表，发现了一个 issue(#7739),里面提到了可以使用插件 serverless 来实现我们的需求。
serverless 介绍 APISIX 有两个 serverless 插件：serverless-pre-function 和 serverless-post-function。
serverless-pre-function 插件会在指定阶段开始时运行，serverless-post-function 插件会在指定阶段结束时运行。这两个插件使用相同的属性。
实现 我们的需求应该是采用 serverless-pre-function 来实现，具体过程描述如下：获得请求的 host, 对 host 进行相应的文本正则替换，将替换的文本和 uri 进行组合拼接，得到真正的 uri.
...</p></div><footer class=entry-footer><span title='2023-03-04 23:29:36 +0800 +0800'>三月 4, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to apisix 根据请求 host 访问不同路径" href=https://jasminides.com/posts/apisix%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82host%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用 acme 自动更新 APISIX ssl 证书</h2></header><div class=entry-content><p>前言 最近在给 APISIX 配置自动更新 SSL 证书的时候，发现了一些问题，本文记录以下发现问题的过程和解决方案。
步骤 我们先来看下原始的配置方法吧：
1 安装相应脚本
$ curl --output /root/.acme.sh/renew-hook-update-APISIX.sh --silent https://gist.githubusercontent.com/anjia0532/9ebf8011322f43e3f5037bc2af3aeaa6/raw/65b359a4eed0ae990f9188c2afa22bacd8471652/renew-hook-update-APISIX.sh $ chmod +x /root/.acme.sh/renew-hook-update-APISIX.sh $ /root/.acme.sh/renew-hook-update-APISIX.sh Usage : /root/.acme.sh/renew-hook-update-APISIX.sh -h &lt;APISIX admin host> -p &lt;certificate pem file> -k &lt;certificate private key file> -a &lt;admin api key> -t &lt;print debug info switch off/on,default off> 2 安装 acme.sh
curl https://get.acme.sh | sh -s email=my@example.com 3 申请证书，并添加 renew-hook
这里我采用的是 dns api 的方式申请证书的
~/.acme.sh/acme.sh --issue --dns dns_ali -d *.xx.com --renew-hook '~/.acme.sh/renew-hook-update-APISIX.sh -h http://127.0.0.1:9280 -p ~/.acme.sh/"*.xx.com_ecc"/"fullchain.cer" -k ~/.acme.sh/"*.xx.com_ecc"/"*.xx.com.key" -a {admin-key}' --log --debug 这里的 http://127.0.0.1:9280 是你的 APISIX 的 admin 接口地址，admin-key 是你的 key。
...</p></div><footer class=entry-footer><span title='2023-02-25 14:20:59 +0800 +0800'>二月 25, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to 使用 acme 自动更新 APISIX ssl 证书" href=https://jasminides.com/posts/%E4%BD%BF%E7%94%A8acme%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0apisix_ssl%E8%AF%81%E4%B9%A6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Containerd 本地调试环境搭建</h2></header><div class=entry-content><p>最近在学习常用的容器运行时 containerd, 本篇我就来介绍如何本地构建 containerd 进行调试开发，主要介绍 2 种 常规方式和使用容器构建，由于本地环境限制，我主要是使用 docker 搭建本地调试环境。
非容器 build 这里先开始介绍常规直接从源码本地构建的方式。
构建环境要求 1 go1.19.x 及以上版本
2 Protoc 3.x+
3 适用于您的发行版的 Btrfs 标头和库。请注意，可以通过构建标签禁用构建 btrfs 驱动程序 no_btrfs，从而删除此依赖项。
前面 2 点相信大家都很清楚，第三点的 Btrfs 是什么呢？Btrfs 是一种现代的 Linux 写时复制（COW）文件系统，旨在实现先进的功能，同时也注重容错、修复和简易管理。
build 1 拉取 containerd 源代码至本地
2 构建
进入源代码根目录，执行一下命令：
cd containerd make 执行后，会在 ./bin/ 目录下生成所有项目的二进制文件。
如果你需要修改 gRPC API ,修改后需要使用 protoc 编译生成新的代码：make generate
docker 容器构建 接下来讲解怎么通过 docker 构建本地 containerd 调试环境。
构建要求 1 go1.19.x 及以上版本
2 Protoc 3.x+
...</p></div><footer class=entry-footer><span title='2023-02-19 00:43:59 +0800 +0800'>二月 19, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Containerd 本地调试环境搭建" href=https://jasminides.com/posts/containerd%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jasminides.com/posts/page/6/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://jasminides.com/posts/page/8/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2024-now - overstarry · All rights reserved<br></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>