<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Overstarry Site</title><meta name=keywords content><meta name=description content="Posts - Overstarry Site"><meta name=author content="overstarry"><link rel=canonical href=https://jasminides.com/posts/><meta name=google-site-verification content="gfdsdx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=https://jasminides.com/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://jasminides.com/img/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jasminides.com/img/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jasminides.com/img/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://jasminides.com/img/favicon/apple-touch-icon.png><link rel=mask-icon href=https://jasminides.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jasminides.com/posts/index.xml><link rel=alternate hreflang=zh href=https://jasminides.com/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-G40XG2SPQN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G40XG2SPQN")}</script><meta property="og:url" content="https://jasminides.com/posts/"><meta property="og:site_name" content="Overstarry Site"><meta property="og:title" content="Posts"><meta property="og:description" content="Overstarry 记录 AI 助理、MCP 集成与个人开发总结的 Hugo 博客"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://jasminides.com/img/generics1-fs8.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jasminides.com/img/generics1-fs8.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Overstarry 记录 AI 助理、MCP 集成与个人开发总结的 Hugo 博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jasminides.com/posts/"}]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2240998016636586" crossorigin=anonymous></script><link rel=manifest href=https://jasminides.com/site.webmanifest></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jasminides.com/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jasminides.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://jasminides.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://jasminides.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://jasminides.com/index.xml title=rss><span>rss</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://jasminides.com/>主页</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 实现简单反向代理</h2></header><div class=entry-content><p>前言 说起反向代理，大家应该都不陌生，是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。常见的反向代理有 Nginx,HAProxy,Apisix 等。
接下来介绍如何使用 go 实现一个反向代理服务器。
golang 实现 使用 golang 实现反向代理非常简单，标准库 net/http/httputil 提供了反向代理的方法可以让我们方便的实现反向代理，使我们可以很快的实现一个简单的反向代理服务器。
package main import ( "log" "net/http" "net/http/httputil" "net/url" ) func NewProxy(targetHost string) (*httputil.ReverseProxy, error) { url, err := url.Parse(targetHost) if err != nil { return nil, err } return httputil.NewSingleHostReverseProxy(url), nil } func ProxyRequestHandler(proxy *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) { return func(w http.ResponseWriter, r *http.Request) { proxy.ServeHTTP(w, r) } } func main() { proxy, err := NewProxy("https://overstarry.vip") if err != nil { panic(err) } http.HandleFunc("/", ProxyRequestHandler(proxy)) log.Fatal(http.ListenAndServe(":8080", nil)) } 这段代码将到达我们代理服务器的任何请求都会被代理到 https://overstarry.vip。我们运行代码，访问网站，发现 403 Forbidden 好像请求被拦截了，应该是源网站进行了请求校验，这该怎么处理呢？通过查阅资料得知，我们需要将 host 传递过去，修改后的代码如下：
package main import ( "log" "net/http" "net/http/httputil" "net/url" ) func NewProxy(targetHost string) (*httputil.ReverseProxy, error) { url, err := url.Parse(targetHost) if err != nil { return nil, err } return httputil.NewSingleHostReverseProxy(url), nil } func ProxyRequestHandler(proxy *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) { return func(w http.ResponseWriter, r *http.Request) { r.Host = "overstarry.vip" proxy.ServeHTTP(w, r) } } func main() { proxy, err := NewProxy("https://overstarry.vip") if err != nil { panic(err) } http.HandleFunc("/", ProxyRequestHandler(proxy)) log.Fatal(http.ListenAndServe(":8080", nil)) } 现在运行代码即可正常访问了。
...</p></div><footer class=entry-footer><span title='2023-04-08 17:12:41 +0800 +0800'>四月 8, 2023</span>&nbsp;·&nbsp;<span title='2025-11-28 23:59:17 +0800 +0800'>Updated 十一月 28, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 实现简单反向代理" href=https://jasminides.com/posts/go-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CertificateManager 使用 dns 授权申请证书 -- gcloud 方式</h2></header><div class=entry-content><p>本文讲解如何使用 dns 授权方式申请 google cloud 证书，通过查阅官方文档可以得知可以使用 gcloud 和 Certificate Manager API 来申请证书，本文使用 gcloud 命令行工具来执行步骤。
创建 DNS 授权 第一步是创建 DNS 授权，使用以下命令来创建：
gcloud certificate-manager dns-authorizations create AUTHORIZATION_NAME \ --domain="DOMAIN_NAME" gcloud certificate-manager dns-authorizations describe AUTHORIZATION_NAME 需要将 AUTHORIZATION_NAME 和 DOMAIN_NAME 分别替换为 dns 授权的名称和相应的域名。
先创建 dns 授权然后查看授权的详细信息
gcloud certificate-manager dns-authorizations create overstarry --domain="overstarry.vip" gcloud certificate-manager dns-authorizations describe overstarry 根据返回的 cname 信息，需要到相应的域名解析中添加 cname 记录。
创建引用 DNS 授权的 Google 管理的证书 接下来 创建引用 DNS 授权的 Google 管理的证书，使用以下命令创建：
...</p></div><footer class=entry-footer><span title='2023-03-29 10:42:59 +0800 +0800'>三月 29, 2023</span>&nbsp;·&nbsp;<span title='2025-11-28 23:59:17 +0800 +0800'>Updated 十一月 28, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to CertificateManager 使用 dns 授权申请证书 -- gcloud 方式" href=https://jasminides.com/posts/certificatemanager-%E4%BD%BF%E7%94%A8-dns-%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E8%AF%81%E4%B9%A6--gcloud-%E6%96%B9%E5%BC%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Google Cloud 清除 CDN 缓存</h2></header><div class=entry-content><p>最近在研究使用 google cloud 的 cdn 服务，本文就来讲解如何清除 cdn 的缓存。
本文介绍了几种清除 cdn 缓存的方法。
google cloud console 清除 第一种也是最简单的，就是直接从 google cloud console 后台进行操作，我们打开 console 后台，选择网络服务，点击负载均衡界面，选择我们要清除的 cdn 缓存所使用的负载均衡器，点击缓存页面， 输入想要 cdn 节点清除的路径即可。过了一会，就可以看到操作成功，相应的文件已经失效。 Google Cloud CLI 命令 第二种方法是使用 Google Cloud CLI 使 cdn 缓存文件失效。
Google Cloud CLI 安装 该怎么安装 Google Cloud CLI 呢，有 2 个办法：1) 直接下载安装二进制文件 2) 使用 Cloud Shell. 本文是使用 Cloud Shell 进行的操作。
使缓存内容失效 1 使用 gcloud compute url-maps list 列出目前所使用的负载均衡器
...</p></div><footer class=entry-footer><span title='2023-03-25 14:33:23 +0800 +0800'>三月 25, 2023</span>&nbsp;·&nbsp;<span title='2025-11-28 23:59:17 +0800 +0800'>Updated 十一月 28, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Google Cloud 清除 CDN 缓存" href=https://jasminides.com/posts/google-cloud-%E6%B8%85%E9%99%A4-cdn-%E7%BC%93%E5%AD%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>apisix 数据备份</h2></header><div class=entry-content><p>今天我来讲讲如何备份 apisix 的数据，主要是路由、服务、上游等数据。本文中的 apisix 版本为 apisix 3.1.0 版本。
接下来由我来介绍几种备份方法。
dashboard 导出备份 介绍的第一种方法是使用 apisix dashboard 进行数据导出，但这种方法有许多缺陷，只能导出 route 数据，其他服务、ssl 数据都不能导出，而且新版本 (3.0+)dashboard 导出的路由不包含上游服务的数据，不方便进行快速的路由迁移复制 (我猜测可能是害怕上游服务信息不一致导致路由错误)。
接下来就来介绍如何进行导入导出。
1 我们打开 dashboard
2 选择要导出的路由，点击 export openapi
3 在新的 apisix dashboard 导入刚刚导出的 openapi 文件并填写相应的信息，导入成功后就可以看到导入的路由信息，相应路由的服务需要补充填写。
根据 admin api 编写相应的脚本 apisix 提供了各种 route、service 的 admin api 数据接口，我们可以根据官方提供的接口编写相应的脚本。
使用 etcd 备份方案 由于 apisix 默认采用 etcd 进行数据存储，我们可以备份 etcd 数据，到新的 apisix 集群导入备份的数据。
由于我对 etcd 的运维不太熟悉，想要了解 etcd 备份快照，可以查看这条链接。
...</p></div><footer class=entry-footer><span title='2023-03-18 23:17:24 +0800 +0800'>三月 18, 2023</span>&nbsp;·&nbsp;<span title='2025-11-28 23:59:17 +0800 +0800'>Updated 十一月 28, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to apisix 数据备份" href=https://jasminides.com/posts/apisix-%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>apisix 如何添加自定义插件</h2></header><div class=entry-content><p>最近在研究 apisix 插件，想要研究插件的执行流程，为了了解插件的具体运行流程，查看了几种方法来调试:1. inspect plugin 2. 自定义插件调试 等等。
本文介绍了添加启用自定义插件。
简单修改插件 最近在研究 apisix 的 proxy-cache 插件，本文就以 proxy-cache 插件为例子来讲解 docker 环境下如何自定义插件。
我们先从 apisix 官方 git 库拷贝 proxy-cache 插件代码到本地文件夹。我们对插件的内容进行修改删除，并将插件名称修改为 proxy-cache2, 修改后的插件文件列表如下：
删除了内存缓存的相关内容，只保留了磁盘缓存的内容，并添加了一些日志记录好了解整个插件的整体流程。
apisix 添加自定义插件 接下来需要给 apisix 添加我们修改的 proxy-cache2 插件，通过查看容器的目录，我们需要将插件挂载到 /usr/local/apisix/apisix/plugins 目录下，我们修改 docker-compose 文件：
version: "3" services: apisix: image: apache/apisix:${APISIX_IMAGE_TAG:-3.2.0-debian} restart: always volumes: - ./apisix_conf/config.yaml:/usr/local/apisix/conf/config.yaml:ro - ./apisix/plugins/proxy-cache2:/usr/local/apisix/apisix/plugins/proxy-cache2 - ./apisix_log://usr/local/apisix/logs depends_on: - etcd ##network_mode: host ports: - "9180:9180/tcp" - "9080:9080/tcp" - "9091:9091/tcp" - "9443:9443/tcp" - "9092:9092/tcp" networks: apisix: 我们添加 ./apisix/plugins/proxy-cache2:/usr/local/apisix/apisix/plugins/proxy-cache2 将本地的插件目录挂载进行容器中，重启 apisix。
...</p></div><footer class=entry-footer><span title='2023-03-12 11:40:27 +0800 +0800'>三月 12, 2023</span>&nbsp;·&nbsp;<span title='2025-11-28 23:59:17 +0800 +0800'>Updated 十一月 28, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to apisix 如何添加自定义插件" href=https://jasminides.com/posts/apisix-%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>apisix 根据请求 host 访问不同路径</h2></header><div class=entry-content><p>前言 最近有一个需求，需要配置一个路由，这个路由是子域名形式的，域名类似 xx.apps.overstarry.vip，我们需要根据子域名中的 xx 内容来请求同一个对象存储中不同的文件。
这个需求之前处理过，那时采用了 nginx 来处理主要路径的逻辑，apisix 直接请求 nginx 服务，也就是大概这样的一种结构：apisix -> nginx -> oss。这次同样的需求，我决定采用 2 层结构，去除中间的 nginx 层，由 apisix 直接访问 oss 服务。
接下来我就来讲述处理的过程。
过程 使用 proxy-rewrite 处理这个需求，我第一反应是使用 proxy-rewrite 插件来处理，我使用 regex_uri 字段来进行正则替换匹配，添加的插件内容如下：
"proxy-rewrite": { "regex_uri": [ "^(.*).apps0.overstarry.vip(.*)$", "/$1/production$2" ] } 配置完后，请求了几次，发现没有请求成功，通过查看日志发现请求到了奇怪的地址。又仔细的研究了一会，发现是我理解错误了，proxy_rewrite 是根据 uri 进行正则匹配的，没有根据 host 匹配的选项，前面填写的那些是根本不会匹配成功的。
serverless proxy-rewrite 插件不能实现我们的需求，我又查看了 issue 列表，发现了一个 issue(#7739),里面提到了可以使用插件 serverless 来实现我们的需求。
serverless 介绍 APISIX 有两个 serverless 插件：serverless-pre-function 和 serverless-post-function。
serverless-pre-function 插件会在指定阶段开始时运行，serverless-post-function 插件会在指定阶段结束时运行。这两个插件使用相同的属性。
实现 我们的需求应该是采用 serverless-pre-function 来实现，具体过程描述如下：获得请求的 host, 对 host 进行相应的文本正则替换，将替换的文本和 uri 进行组合拼接，得到真正的 uri.
...</p></div><footer class=entry-footer><span title='2023-03-04 23:29:36 +0800 +0800'>三月 4, 2023</span>&nbsp;·&nbsp;<span title='2025-11-28 23:59:17 +0800 +0800'>Updated 十一月 28, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to apisix 根据请求 host 访问不同路径" href=https://jasminides.com/posts/apisix-%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82-host-%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用 acme 自动更新 APISIX ssl 证书</h2></header><div class=entry-content><p>前言 最近在给 APISIX 配置自动更新 SSL 证书的时候，发现了一些问题，本文记录以下发现问题的过程和解决方案。
步骤 我们先来看下原始的配置方法吧：
1 安装相应脚本
$ curl --output /root/.acme.sh/renew-hook-update-APISIX.sh --silent https://gist.githubusercontent.com/anjia0532/9ebf8011322f43e3f5037bc2af3aeaa6/raw/65b359a4eed0ae990f9188c2afa22bacd8471652/renew-hook-update-APISIX.sh $ chmod +x /root/.acme.sh/renew-hook-update-APISIX.sh $ /root/.acme.sh/renew-hook-update-APISIX.sh Usage : /root/.acme.sh/renew-hook-update-APISIX.sh -h &lt;APISIX admin host> -p &lt;certificate pem file> -k &lt;certificate private key file> -a &lt;admin api key> -t &lt;print debug info switch off/on,default off> 2 安装 acme.sh
curl https://get.acme.sh | sh -s email=my@example.com 3 申请证书，并添加 renew-hook
这里我采用的是 dns api 的方式申请证书的
~/.acme.sh/acme.sh --issue --dns dns_ali -d *.xx.com --renew-hook '~/.acme.sh/renew-hook-update-APISIX.sh -h http://127.0.0.1:9280 -p ~/.acme.sh/"*.xx.com_ecc"/"fullchain.cer" -k ~/.acme.sh/"*.xx.com_ecc"/"*.xx.com.key" -a {admin-key}' --log --debug 这里的 http://127.0.0.1:9280 是你的 APISIX 的 admin 接口地址，admin-key 是你的 key。
...</p></div><footer class=entry-footer><span title='2023-02-25 14:20:59 +0800 +0800'>二月 25, 2023</span>&nbsp;·&nbsp;<span title='2025-11-28 23:59:17 +0800 +0800'>Updated 十一月 28, 2025</span>&nbsp;·&nbsp;5 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to 使用 acme 自动更新 APISIX ssl 证书" href=https://jasminides.com/posts/%E4%BD%BF%E7%94%A8-acme-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-apisix-ssl-%E8%AF%81%E4%B9%A6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Containerd 本地调试环境搭建</h2></header><div class=entry-content><p>最近在学习常用的容器运行时 containerd, 本篇我就来介绍如何本地构建 containerd 进行调试开发，主要介绍 2 种 常规方式和使用容器构建，由于本地环境限制，我主要是使用 docker 搭建本地调试环境。
非容器 build 这里先开始介绍常规直接从源码本地构建的方式。
构建环境要求 1 go1.19.x 及以上版本
2 Protoc 3.x+
3 适用于您的发行版的 Btrfs 标头和库。请注意，可以通过构建标签禁用构建 btrfs 驱动程序 no_btrfs，从而删除此依赖项。
前面 2 点相信大家都很清楚，第三点的 Btrfs 是什么呢？Btrfs 是一种现代的 Linux 写时复制（COW）文件系统，旨在实现先进的功能，同时也注重容错、修复和简易管理。
build 1 拉取 containerd 源代码至本地
2 构建
进入源代码根目录，执行一下命令：
cd containerd make 执行后，会在 ./bin/ 目录下生成所有项目的二进制文件。
如果你需要修改 gRPC API ,修改后需要使用 protoc 编译生成新的代码：make generate
docker 容器构建 接下来讲解怎么通过 docker 构建本地 containerd 调试环境。
构建要求 1 go1.19.x 及以上版本
2 Protoc 3.x+
...</p></div><footer class=entry-footer><span title='2023-02-19 00:43:59 +0800 +0800'>二月 19, 2023</span>&nbsp;·&nbsp;<span title='2025-11-28 23:59:17 +0800 +0800'>Updated 十一月 28, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Containerd 本地调试环境搭建" href=https://jasminides.com/posts/containerd-%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>containerd 安装和客户端简单使用</h2></header><div class=entry-content><p>介绍 containerd 是一个用于管理容器生命周期的开源容器守护程序，是 Docker 引擎中的核心组件之一。它负责容器的创建、启动、停止、销毁等操作，并提供了对容器的基本管理功能，如镜像管理、网络管理、存储管理等。与 Docker 引擎相比，containerd 更加轻量级，同时也支持多种容器运行时，如 runc、gVisor、Kata Containers 等。由于其简单、可扩展和可移植等优点，containerd 也成为了许多容器平台和工具的基础组件之一。
安装 本文只介绍 Linux 系统下的安装方式。Linux 下的 deb 和 rpm 包 containerd.io 由 docker 官方进行分发，通过查阅官方文档，具体的安装步骤如下：
1 更新 apt 软件包索引并安装必要的软件包，以便 apt 能够使用 HTTPS 仓库。
sudo apt-get update sudo apt-get install \ ca-certificates \ curl \ gnupg \ lsb-release 2 添加 Docker’s 官方 GPG key:
sudo mkdir -m 0755 -p /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg 3 设置存储库
echo \ "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null sudo apt-get update 4 安装
...</p></div><footer class=entry-footer><span title='2023-02-11 21:57:19 +0800 +0800'>二月 11, 2023</span>&nbsp;·&nbsp;<span title='2025-11-28 23:59:17 +0800 +0800'>Updated 十一月 28, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to containerd 安装和客户端简单使用" href=https://jasminides.com/posts/containerd-%E5%AE%89%E8%A3%85%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Helm 介绍及使用</h2></header><div class=entry-content><p>今天我来简单介绍 kubernetes 生态中一个重要一环 - 包管理工具 Helm。
介绍 Helm 是 Kubernetes 的开源包管理器。它提供了提供、共享和使用为 Kubernetes 构建的软件的能力。
Helm 于 2015 年在 Deis 创建，后来被微软收购。现在称为 Helm Classic 的是在当年 11 月的首届 KubeCon 上推出的。2016 年 1 月，Helm Classic 与谷歌的 Kubernetes 部署管理器合并到现在是 Helm 主要项目的存储库中。
该项目目前拥有超过 30,000 个 GitHub stars，每月从全球获得超过 200 万次下载。2020 年 4 月，Helm 在 CNCF 中获得毕业。
安装 Helm 二进制安装 1 打开 https://github.com/helm/helm/releases , 下载你需要的版本 2 解压安装包 3 将文件夹中的 helm 二进制文件移动到相应的位置
脚本安装 helm 官方提供了一个安装的脚本：
$ curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 $ chmod 700 get_helm.sh $ ./get_helm.sh 除了以上 2 种安装方式，你还可以通过各个操作系统的包管理工具安装和编译源码安装，这里就不过多赘述了。
...</p></div><footer class=entry-footer><span title='2023-02-04 14:31:08 +0800 +0800'>二月 4, 2023</span>&nbsp;·&nbsp;<span title='2025-11-28 23:59:17 +0800 +0800'>Updated 十一月 28, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Helm 介绍及使用" href=https://jasminides.com/posts/helm-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jasminides.com/posts/page/7/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://jasminides.com/posts/page/9/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2024-now - overstarry · All rights reserved<br></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>