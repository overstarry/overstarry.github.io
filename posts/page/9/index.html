<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Overstarry Site</title>
<meta name=keywords content><meta name=description content="Posts - Overstarry Site"><meta name=author content="overstarry"><link rel=canonical href=https://jasminides.com/posts/><meta name=google-site-verification content="gfdsdx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://jasminides.com/img/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jasminides.com/img/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jasminides.com/img/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://jasminides.com/img/favicon/apple-touch-icon.png><link rel=mask-icon href=https://jasminides.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jasminides.com/posts/index.xml><link rel=alternate hreflang=zh href=https://jasminides.com/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-G40XG2SPQN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G40XG2SPQN")}</script><meta property="og:url" content="https://jasminides.com/posts/"><meta property="og:site_name" content="Overstarry Site"><meta property="og:title" content="Posts"><meta property="og:description" content="overstarry site"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://jasminides.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jasminides.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="overstarry site"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jasminides.com/posts/"}]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2240998016636586" crossorigin=anonymous></script><link rel=manifest href=/site.webmanifest></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jasminides.com/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jasminides.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://www.overstarry.com/ title=game><span>game</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://jasminides.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://jasminides.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://jasminides.com/index.xml title=rss><span>rss</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://jasminides.com/>主页</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Fly.io 初体验</h2></header><div class=entry-content><p>前言 最近在群里看到群友提到了 Fly.io 这个 应用部署平台，相比其它平台，Fly.io 提供了数据库。本篇文章我就来简单介绍如何使用 Fly.io。
安装 flyctl Flyctl 是一个应用命令行工具，可以让你很方便的从创建用户、创建应用并部署应用。
Windows 安装 iwr https://fly.io/install.ps1 -useb | iex Linux 安装 curl -L https://fly.io/install.sh | sh MAC 安装 brew install flyctl 或者
curl -L https://fly.io/install.sh | sh 注册 Fly.io 账号 使用 flyctl auth signup 命令进行用户注册，你可以使用电子邮件注册，也可以使用 Github 账号进行登录。
登录账号 使用 flyctl auth login 命令登录你的 Fly.io 账号，由于我没有 Fly.io 账号，前面注册时就会登录，可以直接跳过这步。
启动应用程序 接下来我们就可以进行应用的部署了，Fly.io 使用的是 docker 镜像的方式进行应用部署的，由于我本地环境的限制，本文我使用一个基础的 flyio/hellofly:latest 镜像进行部署使用。
每个应用使用 fly.toml 配置文件来告诉 Fly.io 如何进行部署。我们使用 flyctl launch 命令生成相应的配置文件。
...</p></div><footer class=entry-footer><span title='2022-10-22 22:30:36 +0800 +0800'>十月 22, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Fly.io 初体验" href=https://jasminides.com/posts/fly.io%E5%88%9D%E4%BD%93%E9%AA%8C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AI 绘画初体验</h2></header><div class=entry-content><p>前言 最近我发现各个群里出现了一股利用 AI 进行绘画的潮流，今天我也尝试使用 Stable Diffusion 模型 进行 AI 绘画。
Stable Diffusion 简介 Stable Diffusion 是一个文本到图像的模型，将使人们可以在几秒钟内创造出令人惊叹的艺术作品。它在速度和质量方面都有突破，这意味着它可以在消费级 GPU 上运行
开始 我们采用别人封装的 stable-diffusion-webui 平台进行绘画，由于各种条件限制，我们使用 github 上提供的 Google colab notbook 进行部署 (https://colab.research.google.com/drive/1IplUv47g9CgtlJmFnyT2sDyNYDEeMJDi?usp=sharing).
打开链接，我简单的看了下代码，前面是基础的安装运行环境、需要的 Python package .我们依次运行即可。
我们直接来到 1.4 Connect to Google Drive， 勾选 download_if_missing，然后到 https://huggingface.co/settings/tokens 复制你的 toekn 并填入。(huggingface 注册耗费了许多时间，reCAPTCHA 没有通过).
点击运行后就开始拉取模型。
如果运行发现报错了：
remote: Access to model CompVis/stable-diffusion-v-1-4-original is restricted and you are not in the authorized list. Visit https://huggingface.co/CompVis/stable-diffusion-v-1-4-original to ask for access. fatal: unable to access 'https://huggingface.co/CompVis/stable-diffusion-v-1-4-original/': The requested URL returned error: 403 你需要到 https://huggingface.co/CompVis/stable-diffusion-v-1-4-original 授权模型的访问权限。授权后重新运行即可。
...</p></div><footer class=entry-footer><span title='2022-10-15 22:19:32 +0800 +0800'>十月 15, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to AI 绘画初体验" href=https://jasminides.com/posts/ai%E7%BB%98%E7%94%BB%E5%88%9D%E4%BD%93%E9%AA%8C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kubernetes Configmaps mounted with subPath not update when changed</h2></header><div class=entry-content><p>起因 最近在使用 k8s 部署应用时，我使用 ConfigMaps 的方式来挂载应用的配置文件。在我的知识储备中，k8s 修改 cm 的内容，pod 里的配置文件应该也会同步更新才是，但是我进入 pod , 发现配置还是旧版本没有更新，需要重启 pod 才会生效。
问题 那为什么配置没有及时更新呢？通过查阅资料，我发现使用 subPath 挂载的容器不会接收到配置更新。这是为什么呢，相比于没有使用 subPath 有什么区别呢？
subPath 使用了符号链接的方式挂载文件，容器内的文件是一个链接到存储在一个隐藏的带有时间戳目录中的同名文件。当 configMaps 更新时，符号链接会更新，但挂载在容器中的文件绑定保持不变。
解决 使用 path 字段为特定 ConfigMap 项指定所需的文件路径 具体如下：
apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: registry.k8s.io/busybox command: [ "/bin/sh","-c","cat /etc/config/keys" ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: name: special-config items: - key: SPECIAL_LEVEL path: keys restartPolicy: Never 亲测这样是可以正常更新的，但同目录下的其它文件会删除掉，看了几个相关的 issues , 发现你还可以手动创建符号链接到相应的文件夹，
小结 使用 subPath 挂载配置至容器时，配置更新时，容器内的配置不能同步更新，这是 k8s 官方处于各种原因做出的限制，目前还没有很好的办法来解决这个问题。
参考 https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#mounted-configmaps-are-updated-automatically https://github.com/kubernetes/kubernetes/issues/50345 https://github.com/kubernetes/kubernetes/blob/master/pkg/volume/util/atomic_writer.go</p></div><footer class=entry-footer><span title='2022-10-02 13:05:57 +0800 +0800'>十月 2, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Kubernetes Configmaps mounted with subPath not update when changed" href=https://jasminides.com/posts/kubernetes-configmaps-subpath-no-reload/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Easeprobe 简单介绍使用</h2></header><div class=entry-content><p>本篇文章将由我来介绍一款健康/状态检查工具 - Easeprobe 的简单使用。
介绍 EaseProbe 是一个由用 Go 编写的简单、独立、轻量级的工具，可以进行健康/状态检查，
EaseProbe 主要完成 3 个目标工具：探测、通知、报告
探测 EaseProbe 支持多种方法来执行其探测，例如：
* HTTP。检查 HTTP 状态码，支持 mTLS，HTTP Basic Auth，可以设置 Request Header/Body。（HTTP 探针配置） * TCP。检查是否可以建立 TCP 连接。(TCP 探针配置) * shell。运行 Shell 命令并检查结果。（Shell 命令探针配置） * SSH。通过 SSH 运行远程命令并检查结果。支持堡垒/跳转服务器（SSH 命令探针配置） * TLS。使用 TLS 连接到给定端口并（可选）验证已撤销或过期的证书（TLS 探针配置） * Host。在远程主机上运行 SSH 命令并检查 CPU、内存和磁盘使用情况。（主机负载探针） * client。支持以下本机客户端。它们都支持 mTLS 和数据检查，请参阅 Native Client Probe 配置 * MySQL。连接到 MySQL 服务器并运行 SHOW STATUSSQL。 * Redis。连接到 Redis 服务器并运行 PING 命令。 * Memcache。连接到 Memcache 服务器并运行 version 命令或验证给定的键/值对。 * MongoDB。连接到 MongoDB 服务器并执行 ping。 * Kafka。连接到 Kafka 服务器并执行所有主题的列表。 * PostgreSQL。连接到 PostgreSQL 服务器并运行 SELECT 1SQL。 * Zookeeper。连接到 Zookeeper 服务器并运行 get /命令。 通知 EaseProbe 支持多种通知方式向你发送通知，例如：slack、钉钉、企业微信、邮件、Telegram 等。
...</p></div><footer class=entry-footer><span title='2022-09-24 16:28:44 +0800 +0800'>九月 24, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Easeprobe 简单介绍使用" href=https://jasminides.com/posts/easeprobe%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%BD%BF%E7%94%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>gRPC 中间件</h2></header><div class=entry-content><p>本文我来介绍 gRPC 中的中间件相关知识。
介绍 gRPC 中间件基于前面讲解的拦截器相关概念，它是一组拦截器、辅助、工具的集合，在我们使用 gRPC 开发应用时，往往会使用到各种中间件。它允许在服务端或客户端以拦截器链条形式应用多个中间件。因为拦截器经常用来实现一些通用的功能 ,如鉴权认证、日志、监控等，所以使用 gRPC 中间件来实现这些可重用功能是十分合适的。下面的代码就分别暂时服务端和客户端使用中间件的例子：
import "github.com/grpc-ecosystem/go-grpc-middleware" myServer := grpc.NewServer( grpc.StreamInterceptor(grpc_middleware.ChainStreamServer( grpc_ctxtags.StreamServerInterceptor(), grpc_opentracing.StreamServerInterceptor(), grpc_prometheus.StreamServerInterceptor, grpc_zap.StreamServerInterceptor(zapLogger), grpc_auth.StreamServerInterceptor(myAuthFunction), grpc_recovery.StreamServerInterceptor(), )), grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer( grpc_ctxtags.UnaryServerInterceptor(), grpc_opentracing.UnaryServerInterceptor(), grpc_prometheus.UnaryServerInterceptor, grpc_zap.UnaryServerInterceptor(zapLogger), grpc_auth.UnaryServerInterceptor(myAuthFunction), grpc_recovery.UnaryServerInterceptor(), )), ) import "github.com/grpc-ecosystem/go-grpc-middleware" clientConn, err = grpc.Dial( address, grpc.WithUnaryInterceptor(grpc_middleware.ChainUnaryClient(monitoringClientUnary, retryUnary)), grpc.WithStreamInterceptor(grpc_middleware.ChainStreamClient(monitoringClientStream, retryStream)), ) 常用的中间件 go-grpc-middleware 项目提供了一些常用的中间件：
认证 grpc_auth - 一个可定制的（通过 AuthFunc）身份验证中间件 日志记录 grpc_ctxtags - 将 Tag 地图添加到上下文的库，数据从请求正文填充 grpc_zap - 将 zap 日志库集成到 gRPC 处理程序中。 grpc_logrus - 将 logrus 日志库集成到 gRPC 处理程序中。 grpc_kit - 将 go-kit/log 日志库集成到 gRPC 处理程序中。 grpc_grpc_logsettablegrpclog.LoggerV2 - 一个允许在运行时替换记录器的包装器（线程安全）。 监控 grpc_prometheus - Prometheus 客户端和服务器端监控中间件 otgrpc - OpenTracing 客户端和服务器端拦截器 grpc_opentracing - OpenTracing 客户端和服务器端拦截器，支持流式处理和处理程序返回的标签 otelgrpc - OpenTelemetry 客户端和服务器端拦截器 客户端中间件 grpc_retry - 一个通用的 gRPC 响应代码重试机制，客户端中间件
...</p></div><footer class=entry-footer><span title='2022-09-18 00:06:58 +0800 +0800'>九月 18, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to gRPC 中间件" href=https://jasminides.com/posts/grpc%E4%B8%AD%E9%97%B4%E4%BB%B6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Gitlab CVE-2021-22205</h2></header><div class=entry-content><p>起因 最近一台服务器出现服务器资源 cpu、内存过高的情况，通过对进程的分析，发现是 gitlab 容器进程，怀疑是 gitlab 被入侵运行了挖矿病毒，通过对 gitlab 日志的分析，可以得出入侵者是利用了 gitlab 的 CVE-2021-22205 的漏洞，对 gitlab 进行了攻击。
CVE-2021-22205 介绍 CVE-2021-22205 是一个严重的严重性漏洞 (CVSS 10.0)，它是由第三方文件解析器 Exif-Tool 对图像文件进行不当验证的结果，导致远程命令执行漏洞，可能导致您的 GitLab 实例被攻击。
以下版本受到漏洞影响:
11.9.x - 13.8.7 13.9.0 - 13.9.5 13.10.0 - 13.10.2 解决 gitlab 发布了 GitLab 13.10.3、13.9.6 和 13.8.8 版本来解决这个漏洞。请尽快升级。
如果无法即使更新和使用热更新补丁解决，可以通过将 exiftool 脚本替换为 cat -。这个解决方案将防止从上传的图像中剥离所有的 exif 数据。
将 /opt/gitlab/embedded/bin/exiftool 脚本内容替换为
#!/bin/bash cat - 这种方法不是长久之计，每次重启容器时都要手动修改文件，还是尽快更新版本。
原因 根据 gitlab 的官方漏洞 issues 来看，当访问接口/uploads/user 上传图像文件时，GitLab Workhorse 会将扩展名为 jpg、jpeg、tiff 文件传递给 ExifTool。用于删除其中不合法的标签。具体的标签在 workhorse/internal/upload/exif/exif.go 中的 startProcessing 方法中有定义，为白名单处理。
...</p></div><footer class=entry-footer><span title='2022-09-10 22:06:22 +0800 +0800'>九月 10, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Gitlab CVE-2021-22205" href=https://jasminides.com/posts/gitlab_cve-2021-22205/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>gRPC 请求抓包</h2></header><div class=entry-content><p>前言 本文来简单介绍如何使用 wireshark 来获取 gRPC 请求。
wireshark 配置 在进行对 gRPC 请求抓包前，得来几个准备。
设置 proto 文件路径 依次打开 编辑 > 首选项 > Protocols > ProtoBuf, 点击如图选项，添加 proto 文件所在的路径。记得勾选右边的 “Load all files” 选项。
设置 TCP 消息解码 默认情况下，界面上显示的都是 TCP 数据包。依次点击菜单栏的 分析 -> 解码为… （或者右击随便一行）。
把 9000 (你的 gRPC 服务端端口) 端口的 TCP 消息解码成 HTTP2 协议信息。
开始抓包 现在开始捕获 gRPC 请求消息，为了避免其他无关的流量，在捕获选项设置筛选 tcp port 9000 只获得跟服务端相关的流量。
我们使用 postman 向服务端发送请求。回到 wireshark 界面，我们就可以看到许多流量，通过前面设置的解码，我们可以很方便的获得 gRPC 消息的具体内容。
小结 本文简单介绍了如何使用 wireshark 捕获 gRPC 请求流量。在使用 Wireshark 抓包时把未识别的 HTTP/2 协议手动设置为 HTTP/2，这样会方便很多。
...</p></div><footer class=entry-footer><span title='2022-09-03 22:46:19 +0800 +0800'>九月 3, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to gRPC 请求抓包" href=https://jasminides.com/posts/grpc%E8%AF%B7%E6%B1%82%E6%8A%93%E5%8C%85/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>gRPC 服务反射协议</h2></header><div class=entry-content><p>本文主要介绍 gRPC 的服务反射协议和相关的应用。
介绍 gRPC 服务反射协议 (server reflection) 是在 gRPC 服务端定义的一个服务，它能提供该服务器端上可公开使用的 gRPC 服务的信息，简单的来说，就是服务反射向客户端提供了服务端注册的服务的信息。因此客户端不需要预编译服务定义就能与服务端交互了。
客户端想要与服务端程序进行通信，必须要有所定义的服务信息，需要编译生产客户端存根，借助 gRPC 服务反射协议，我们就可以无需编译服务定义就能通信。
使用 该如何开启服务反射协议呢？很简单，只需要通过一行代码即可开启：reflection.Register()
package main import ( "context" "flag" "fmt" "log" "net" "google.golang.org/grpc" "google.golang.org/grpc/reflection" ecpb "google.golang.org/grpc/examples/features/proto/echo" hwpb "google.golang.org/grpc/examples/helloworld/helloworld" ) var port = flag.Int("port", 50051, "the port to serve on") // hwServer is used to implement helloworld.GreeterServer. type hwServer struct { hwpb.UnimplementedGreeterServer } // SayHello implements helloworld.GreeterServer func (s *hwServer) SayHello(ctx context.Context, in *hwpb.HelloRequest) (*hwpb.HelloReply, error) { return &amp;hwpb.HelloReply{Message: "Hello " + in.Name}, nil } type ecServer struct { ecpb.UnimplementedEchoServer } func (s *ecServer) UnaryEcho(ctx context.Context, req *ecpb.EchoRequest) (*ecpb.EchoResponse, error) { return &amp;ecpb.EchoResponse{Message: req.Message}, nil } func main() { flag.Parse() lis, err := net.Listen("tcp", fmt.Sprintf(":%d", *port)) if err != nil { log.Fatalf("failed to listen: %v", err) } fmt.Printf("server listening at %v\n", lis.Addr()) s := grpc.NewServer() // Register Greeter on the server. hwpb.RegisterGreeterServer(s, &amp;hwServer{}) // Register RouteGuide on the same server. ecpb.RegisterEchoServer(s, &amp;ecServer{}) // Register reflection service on gRPC server. reflection.Register(s) if err := s.Serve(lis); err != nil { log.Fatalf("failed to serve: %v", err) } } 服务端开启服务反射协议后，就可以通过 gRPC CLI 工具来检查服务端了。这里就不多介绍了，接下来我们来看看服务反射协议在 kratos 中的使用。
...</p></div><footer class=entry-footer><span title='2022-08-27 23:50:09 +0800 +0800'>八月 27, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to gRPC 服务反射协议" href=https://jasminides.com/posts/grpc_server_reflection/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Prometheus_operato</h2></header><div class=entry-content><p>安装 Metrics Server 有了 Metrics Server，用户就可以访问 Kubernetes 核心监控数据（core metrics）。这其中包括了 Pod、Node、容器、Service 等主要 Kubernetes 核心概念的 Metrics。
Resource MetricsAPI: https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/resource-metrics-api.md kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml 部署 Prometheus kube-prometheus 下载存储库 git clone https://github.com/prometheus-operator/kube-prometheus 使用 manifests 中的配置文件创建监控 stack cd kube-prometheus kubectl create -f manifests/setup until kubectl get servicemonitors --all-namespaces ; do date; sleep 1; echo ""; done kubectl create -f manifests/ 访问 dashboards 通过 kubectl --namespace monitoring port-forward svc/prometheus-k8s 9090 就能展现prometheus ui grafana
kubectl --namespace monitoring port-forward svc/grafana 3000 默认账户密码 admin/admin，进入后会要求修改密码，可以看到已经有了预添加了数据源 可以看到有了许多 K8S 监控的默认看板 ...</p></div><footer class=entry-footer><span title='2022-08-23 22:18:08 +0800 +0800'>八月 23, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Prometheus_operato" href=https://jasminides.com/posts/prometheus_operato/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 进行浏览器网页截图</h2></header><div class=entry-content><p>前言 在本文中将介绍使用 golang 进行加载某个网站并进行截图。
chromedp 我们将使用 chromedp 通过浏览器驱动来加载网页并截图。具体的步骤如下：
1 启动 chrome 浏览器 2 加载网页 (还可进行其他浏览器操作) 3 截图并保存
需要注意的是项目使用了 Chrome 的驱动，如果没有 Chrome 将不能顺利运行，需要运行 https://hub.docker.com/r/chromedp/headless-shell/ 来进行 或运行其他 版本的 Chrome。
安装 go get -u github.com/chromedp/chromedp 示例 package main import ( "context" "io/ioutil" "log" "github.com/chromedp/chromedp" ) func main() { ctx, cancel := chromedp.NewContext(context.Background(), chromedp.WithDebugf(log.Printf)) defer cancel() url := "https://www.minigame.vip/" filename := "minigame.png" var imageBuf []byte // 捕获某个元素的截图 if err := chromedp.Run(ctx, elementScreenshot(`https://pkg.go.dev/`, `img.Homepage-logo`, &amp;imageBuf)); err != nil { log.Fatal(err) } if err := ioutil.WriteFile("elementScreenshot.png", imageBuf, 0644); err != nil { log.Fatal(err) } if err := chromedp.Run(ctx, ScreenshotTasks(url, &amp;imageBuf)); err != nil { log.Fatal(err) } if err := ioutil.WriteFile(filename, imageBuf, 0644); err != nil { log.Fatal(err) } } func elementScreenshot(urlstr, sel string, res *[]byte) chromedp.Tasks { return chromedp.Tasks{ chromedp.Navigate(urlstr), chromedp.Screenshot(sel, res, chromedp.NodeVisible), } } func ScreenshotTasks(url string, imageBuf *[]byte) chromedp.Tasks { return chromedp.Tasks{ chromedp.Navigate(url), chromedp.FullScreenshot(imageBuf, 90), } } 上面的例子分别是对网页中的单个元素进行截图和对网页全局截图。
...</p></div><footer class=entry-footer><span title='2022-08-20 22:55:14 +0800 +0800'>八月 20, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 进行浏览器网页截图" href=https://jasminides.com/posts/go%E8%BF%9B%E8%A1%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E9%A1%B5%E6%88%AA%E5%9B%BE/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jasminides.com/posts/page/8/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://jasminides.com/posts/page/10/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2024 - overstarry · All rights reserved<br></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>