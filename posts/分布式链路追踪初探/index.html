<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>分布式链路追踪初探 | Overstarry Site</title>
<meta name=keywords content="OpenTracing,分布式链路追踪"><meta name=description content="微服务架构 作为云原生核心技术之一，提倡将单体应用程序(巨石架构)划分成一组小的服务（微服务），服务之间互相协调、互相配合，为用户提供最终价值。
微服务架构设计中，通常由多个微服务组件组成,有 1) API 网关 ( apisix, kong, traefik ) 负责认证鉴权、负载均衡、限流和静态响应处理; 2) 服务注册发现中心( ZooKeeper、Consul 、ETCD )
,负责服务的注册和发现。3)可观测性 负责日志收集查看的ELK、Loki,负责服务性能指标告警的指标 Metrics 监控 Prometheus, 负责追踪请求的 Tracing
链路追踪。在多个组件的组成下，才能顺利组成一个好的微服务架构。
今天我就来简单的讲一讲微服务组成中可观测性的分布式链路追踪。
OpenTracing 介绍
OpenTracing是一个新的、开放的分布式追踪标准，用于应用程序和OSS包。有过大规模构建微服务经验的开发者都知道分布式追踪的作用和重要性：每个进程的日志和指标监控都有它们的用武之地，但它们都无法重建事务在分布式系统中传播时的复杂旅程。分布式跟踪就是这些旅程。
OpenTracing 项目定义了一套分布式追踪的标准，以统一各种分布式追踪系统的实现。OpenTracing 中包含了一套分布式追踪的标准规范，各种语言的 API，以及实现了该标准的编程框架和函数库。
OpenTracing 提供了平台无关、厂商无关的 API，因此开发者只需要对接 OpenTracing API，无需关心后端采用的到底是什么分布式追踪系统，Jager、Skywalking、LightStep 等都可以无缝切换。
数据模型
OpenTracing 定义了以下数据模型：
Trace （调用链）：一个 Trace 代表一个事务或者流程在（分布式）系统中的执行过程。例如来自客户端的一个请求从接收到处理完成的过程就是一个 Trace。
Span（跨度）：Span 是分布式追踪的最小跟踪单位，一个 Trace 由多段 Span 组成。可以被理解为一次方法调用, 一个程序块的调用, 或者一次 RPC/数据库访问。只要是一个具有完整时间周期的程序访问，都可以被认为是一个
Span。
SpanContext（跨度上下文）：分布式追踪的上下文信息，包括 Trace id，Span id 以及其它需要传递到下游服务的内容。一个 OpenTracing 的实现需要将 SpanContext 通过某种序列化协议 (Wire
Protocol) 在进程边界上进行传递，以将不同进程中的 Span 关联到同一个 Trace 上。对于 HTTP 请求来说，SpanContext 一般是采用 HTTP header 进行传递的。"><meta name=author content="overstarry"><link rel=canonical href=https://jasminides.com/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E5%88%9D%E6%8E%A2/><meta name=google-site-verification content="gfdsdx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://jasminides.com/img/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jasminides.com/img/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jasminides.com/img/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://jasminides.com/img/favicon/apple-touch-icon.png><link rel=mask-icon href=https://jasminides.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://jasminides.com/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E5%88%9D%E6%8E%A2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-G40XG2SPQN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G40XG2SPQN")}</script><meta property="og:title" content="分布式链路追踪初探"><meta property="og:description" content="微服务架构 作为云原生核心技术之一，提倡将单体应用程序(巨石架构)划分成一组小的服务（微服务），服务之间互相协调、互相配合，为用户提供最终价值。
微服务架构设计中，通常由多个微服务组件组成,有 1) API 网关 ( apisix, kong, traefik ) 负责认证鉴权、负载均衡、限流和静态响应处理; 2) 服务注册发现中心( ZooKeeper、Consul 、ETCD )
,负责服务的注册和发现。3)可观测性 负责日志收集查看的ELK、Loki,负责服务性能指标告警的指标 Metrics 监控 Prometheus, 负责追踪请求的 Tracing
链路追踪。在多个组件的组成下，才能顺利组成一个好的微服务架构。
今天我就来简单的讲一讲微服务组成中可观测性的分布式链路追踪。
OpenTracing 介绍
OpenTracing是一个新的、开放的分布式追踪标准，用于应用程序和OSS包。有过大规模构建微服务经验的开发者都知道分布式追踪的作用和重要性：每个进程的日志和指标监控都有它们的用武之地，但它们都无法重建事务在分布式系统中传播时的复杂旅程。分布式跟踪就是这些旅程。
OpenTracing 项目定义了一套分布式追踪的标准，以统一各种分布式追踪系统的实现。OpenTracing 中包含了一套分布式追踪的标准规范，各种语言的 API，以及实现了该标准的编程框架和函数库。
OpenTracing 提供了平台无关、厂商无关的 API，因此开发者只需要对接 OpenTracing API，无需关心后端采用的到底是什么分布式追踪系统，Jager、Skywalking、LightStep 等都可以无缝切换。
数据模型
OpenTracing 定义了以下数据模型：
Trace （调用链）：一个 Trace 代表一个事务或者流程在（分布式）系统中的执行过程。例如来自客户端的一个请求从接收到处理完成的过程就是一个 Trace。
Span（跨度）：Span 是分布式追踪的最小跟踪单位，一个 Trace 由多段 Span 组成。可以被理解为一次方法调用, 一个程序块的调用, 或者一次 RPC/数据库访问。只要是一个具有完整时间周期的程序访问，都可以被认为是一个
Span。
SpanContext（跨度上下文）：分布式追踪的上下文信息，包括 Trace id，Span id 以及其它需要传递到下游服务的内容。一个 OpenTracing 的实现需要将 SpanContext 通过某种序列化协议 (Wire
Protocol) 在进程边界上进行传递，以将不同进程中的 Span 关联到同一个 Trace 上。对于 HTTP 请求来说，SpanContext 一般是采用 HTTP header 进行传递的。"><meta property="og:type" content="article"><meta property="og:url" content="https://jasminides.com/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E5%88%9D%E6%8E%A2/"><meta property="og:image" content="https://jasminides.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-18T22:38:37+08:00"><meta property="article:modified_time" content="2021-09-18T22:38:37+08:00"><meta property="og:site_name" content="overstarry site"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jasminides.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="分布式链路追踪初探"><meta name=twitter:description content="微服务架构 作为云原生核心技术之一，提倡将单体应用程序(巨石架构)划分成一组小的服务（微服务），服务之间互相协调、互相配合，为用户提供最终价值。
微服务架构设计中，通常由多个微服务组件组成,有 1) API 网关 ( apisix, kong, traefik ) 负责认证鉴权、负载均衡、限流和静态响应处理; 2) 服务注册发现中心( ZooKeeper、Consul 、ETCD )
,负责服务的注册和发现。3)可观测性 负责日志收集查看的ELK、Loki,负责服务性能指标告警的指标 Metrics 监控 Prometheus, 负责追踪请求的 Tracing
链路追踪。在多个组件的组成下，才能顺利组成一个好的微服务架构。
今天我就来简单的讲一讲微服务组成中可观测性的分布式链路追踪。
OpenTracing 介绍
OpenTracing是一个新的、开放的分布式追踪标准，用于应用程序和OSS包。有过大规模构建微服务经验的开发者都知道分布式追踪的作用和重要性：每个进程的日志和指标监控都有它们的用武之地，但它们都无法重建事务在分布式系统中传播时的复杂旅程。分布式跟踪就是这些旅程。
OpenTracing 项目定义了一套分布式追踪的标准，以统一各种分布式追踪系统的实现。OpenTracing 中包含了一套分布式追踪的标准规范，各种语言的 API，以及实现了该标准的编程框架和函数库。
OpenTracing 提供了平台无关、厂商无关的 API，因此开发者只需要对接 OpenTracing API，无需关心后端采用的到底是什么分布式追踪系统，Jager、Skywalking、LightStep 等都可以无缝切换。
数据模型
OpenTracing 定义了以下数据模型：
Trace （调用链）：一个 Trace 代表一个事务或者流程在（分布式）系统中的执行过程。例如来自客户端的一个请求从接收到处理完成的过程就是一个 Trace。
Span（跨度）：Span 是分布式追踪的最小跟踪单位，一个 Trace 由多段 Span 组成。可以被理解为一次方法调用, 一个程序块的调用, 或者一次 RPC/数据库访问。只要是一个具有完整时间周期的程序访问，都可以被认为是一个
Span。
SpanContext（跨度上下文）：分布式追踪的上下文信息，包括 Trace id，Span id 以及其它需要传递到下游服务的内容。一个 OpenTracing 的实现需要将 SpanContext 通过某种序列化协议 (Wire
Protocol) 在进程边界上进行传递，以将不同进程中的 Span 关联到同一个 Trace 上。对于 HTTP 请求来说，SpanContext 一般是采用 HTTP header 进行传递的。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jasminides.com/posts/"},{"@type":"ListItem","position":2,"name":"分布式链路追踪初探","item":"https://jasminides.com/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E5%88%9D%E6%8E%A2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"分布式链路追踪初探","name":"分布式链路追踪初探","description":"微服务架构 作为云原生核心技术之一，提倡将单体应用程序(巨石架构)划分成一组小的服务（微服务），服务之间互相协调、互相配合，为用户提供最终价值。\n微服务架构设计中，通常由多个微服务组件组成,有 1) API 网关 ( apisix, kong, traefik ) 负责认证鉴权、负载均衡、限流和静态响应处理; 2) 服务注册发现中心( ZooKeeper、Consul 、ETCD ) ,负责服务的注册和发现。3)可观测性 负责日志收集查看的ELK、Loki,负责服务性能指标告警的指标 Metrics 监控 Prometheus, 负责追踪请求的 Tracing 链路追踪。在多个组件的组成下，才能顺利组成一个好的微服务架构。\n今天我就来简单的讲一讲微服务组成中可观测性的分布式链路追踪。\nOpenTracing 介绍 OpenTracing是一个新的、开放的分布式追踪标准，用于应用程序和OSS包。有过大规模构建微服务经验的开发者都知道分布式追踪的作用和重要性：每个进程的日志和指标监控都有它们的用武之地，但它们都无法重建事务在分布式系统中传播时的复杂旅程。分布式跟踪就是这些旅程。\nOpenTracing 项目定义了一套分布式追踪的标准，以统一各种分布式追踪系统的实现。OpenTracing 中包含了一套分布式追踪的标准规范，各种语言的 API，以及实现了该标准的编程框架和函数库。\nOpenTracing 提供了平台无关、厂商无关的 API，因此开发者只需要对接 OpenTracing API，无需关心后端采用的到底是什么分布式追踪系统，Jager、Skywalking、LightStep 等都可以无缝切换。\n数据模型 OpenTracing 定义了以下数据模型：\nTrace （调用链）：一个 Trace 代表一个事务或者流程在（分布式）系统中的执行过程。例如来自客户端的一个请求从接收到处理完成的过程就是一个 Trace。\nSpan（跨度）：Span 是分布式追踪的最小跟踪单位，一个 Trace 由多段 Span 组成。可以被理解为一次方法调用, 一个程序块的调用, 或者一次 RPC/数据库访问。只要是一个具有完整时间周期的程序访问，都可以被认为是一个 Span。\nSpanContext（跨度上下文）：分布式追踪的上下文信息，包括 Trace id，Span id 以及其它需要传递到下游服务的内容。一个 OpenTracing 的实现需要将 SpanContext 通过某种序列化协议 (Wire Protocol) 在进程边界上进行传递，以将不同进程中的 Span 关联到同一个 Trace 上。对于 HTTP 请求来说，SpanContext 一般是采用 HTTP header 进行传递的。\n","keywords":["OpenTracing","分布式链路追踪"],"articleBody":"微服务架构 作为云原生核心技术之一，提倡将单体应用程序(巨石架构)划分成一组小的服务（微服务），服务之间互相协调、互相配合，为用户提供最终价值。\n微服务架构设计中，通常由多个微服务组件组成,有 1) API 网关 ( apisix, kong, traefik ) 负责认证鉴权、负载均衡、限流和静态响应处理; 2) 服务注册发现中心( ZooKeeper、Consul 、ETCD ) ,负责服务的注册和发现。3)可观测性 负责日志收集查看的ELK、Loki,负责服务性能指标告警的指标 Metrics 监控 Prometheus, 负责追踪请求的 Tracing 链路追踪。在多个组件的组成下，才能顺利组成一个好的微服务架构。\n今天我就来简单的讲一讲微服务组成中可观测性的分布式链路追踪。\nOpenTracing 介绍 OpenTracing是一个新的、开放的分布式追踪标准，用于应用程序和OSS包。有过大规模构建微服务经验的开发者都知道分布式追踪的作用和重要性：每个进程的日志和指标监控都有它们的用武之地，但它们都无法重建事务在分布式系统中传播时的复杂旅程。分布式跟踪就是这些旅程。\nOpenTracing 项目定义了一套分布式追踪的标准，以统一各种分布式追踪系统的实现。OpenTracing 中包含了一套分布式追踪的标准规范，各种语言的 API，以及实现了该标准的编程框架和函数库。\nOpenTracing 提供了平台无关、厂商无关的 API，因此开发者只需要对接 OpenTracing API，无需关心后端采用的到底是什么分布式追踪系统，Jager、Skywalking、LightStep 等都可以无缝切换。\n数据模型 OpenTracing 定义了以下数据模型：\nTrace （调用链）：一个 Trace 代表一个事务或者流程在（分布式）系统中的执行过程。例如来自客户端的一个请求从接收到处理完成的过程就是一个 Trace。\nSpan（跨度）：Span 是分布式追踪的最小跟踪单位，一个 Trace 由多段 Span 组成。可以被理解为一次方法调用, 一个程序块的调用, 或者一次 RPC/数据库访问。只要是一个具有完整时间周期的程序访问，都可以被认为是一个 Span。\nSpanContext（跨度上下文）：分布式追踪的上下文信息，包括 Trace id，Span id 以及其它需要传递到下游服务的内容。一个 OpenTracing 的实现需要将 SpanContext 通过某种序列化协议 (Wire Protocol) 在进程边界上进行传递，以将不同进程中的 Span 关联到同一个 Trace 上。对于 HTTP 请求来说，SpanContext 一般是采用 HTTP header 进行传递的。\nOpenTracing for go 接下来 创建 main.go ，实现一个 Web 服务，并在请求流程中使用 OpenTracing API 进行埋点处理。\ncode:\npackage main import ( \"fmt\" \"log\" \"math/rand\" \"net/http\" \"time\" \"github.com/gin-gonic/gin\" \"github.com/opentracing/opentracing-go\" ) var ( port = \"8080\" addr = \":8080\" ) func main() { engine := gin.New() engine.GET(\"/\", indexHandler) engine.GET(\"/home\", homeHandler) engine.GET(\"/async\", serviceHandler) engine.GET(\"/service\", serviceHandler) engine.GET(\"/db\", dbHandler) fmt.Printf(\"http://localhost:%s\\n\", port) engine.Run(addr) } func dbHandler(c *gin.Context) { var sp opentracing.Span opName := c.Request.URL.Path wireContext, err := opentracing.GlobalTracer().Extract( opentracing.TextMap, opentracing.HTTPHeadersCarrier(r.Header)) if err != nil { // 获取失败，则直接新建一个根节点 span sp = opentracing.StartSpan(opName) } else { sp = opentracing.StartSpan(opName, opentracing.ChildOf(wireContext)) } defer sp.Finish() time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond) } func serviceHandler(c *gin.Context) { // 通过http header，提取span元数据信息 var sp opentracing.Span opName := c.Request.URL.Path wireContext, err := opentracing.GlobalTracer().Extract( opentracing.TextMap, opentracing.HTTPHeadersCarrier(c.Request.Header)) if err != nil { // 获取失败，则直接新建一个根节点 span sp = opentracing.StartSpan(opName) } else { sp = opentracing.StartSpan(opName, opentracing.ChildOf(wireContext)) } defer sp.Finish() dbReq, _ := http.NewRequest(\"GET\", \"http://localhost:8080/db\", nil) err = sp.Tracer().Inject(sp.Context(), opentracing.TextMap, opentracing.HTTPHeadersCarrier(dbReq.Header)) if err != nil { log.Fatalf(\"[dbReq]无法添加span context到http header: %v\", err) } if _, err = http.DefaultClient.Do(dbReq); err != nil { sp.SetTag(\"error\", true) sp.LogKV(\"请求 /db error\", err) } time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond) } func homeHandler(c *gin.Context) { c.String(200, \"开始请求...\\n\") // 设置一个根节点 span span := opentracing.StartSpan(\"请求 /home\") defer span.Finish() asyncReq, _ := http.NewRequest(\"GET\", \"http://localhost:8080/async\", nil) err := span.Tracer().Inject(span.Context(), opentracing.TextMap, opentracing.HTTPHeadersCarrier(asyncReq.Header)) if err != nil { log.Fatalf(\"[asyncReq]无法添加span context到http header: %v\", err) } go func() { if _, err := http.DefaultClient.Do(asyncReq); err != nil { span.SetTag(\"error\", true) span.LogKV(fmt.Sprintf(\"请求 /async error: %v\", err)) } }() time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond) syncReq, _ := http.NewRequest(\"GET\", \"http://localhost:8080/service\", nil) err = span.Tracer().Inject(span.Context(), opentracing.TextMap, opentracing.HTTPHeadersCarrier(syncReq.Header)) if err != nil { log.Fatalf(\"[syncReq]无法添加span context到http header: %v\", err) } if _, err = http.DefaultClient.Do(syncReq); err != nil { span.SetTag(\"error\", true) span.LogKV(fmt.Sprintf(\"请求 /service error: %v\", err)) } c.String(200, \"请求结束！\") } func indexHandler(c *gin.Context) { c.String(200, string(` 点击开始发起请求 `)) } 就这样一个使用 OpenTracing API 进行链路追踪的 web 服务就这样完成了，接下来只需要在应用程序启动时连接到任意实现了 OpenTracing 标准的链路追踪系统即可。\nJaeger 接下来介绍实现了 OpenTracing API 标准的链路追踪系统 Jaeger。\nJaeger 受 Dapper 和 OpenZipkin 的启发，是 Uber Technologies 开源的分布式跟踪系统，遵循 OpenTracing 标准，功能包括：\n分布式上下文传播 监控分布式事务 执行根原因分析 服务依赖分析 优化性能和延迟时间 Jaeger 是云原生计算基金会( CNCF )毕业项目。\n架构 Jaeger可以被部署为一体式二进制，即所有Jaeger后端组件在一个单一进程中运行，也可以被部署为可扩展的分布式系统。\nJaeger 部署 因为环境所限,就采用最简单的部署方式，下载 jaeger-1.26.0-windows-amd64.tar ,解压。\n进入解压后的文件夹，执行命令行 jaeger-all-in-one –processor.zipkin-compact.server-host-port=9411。\n然后在浏览器输入 http://localhost:16686/ ，就可以看到 Jaeger UI 。如下图: Jaeger 使用 上面已经成功安装运行 Jaeger 了, 接下来给我们的应用程序接入 Jaeger。\n安装 Jaeger go Client\ngo get -u github.com/uber/jaeger-client-go 修改后的代码:\npackage main import ( \"fmt\" \"log\" \"math/rand\" \"net/http\" \"time\" \"github.com/gin-gonic/gin\" \"github.com/opentracing/opentracing-go\" \"github.com/uber/jaeger-client-go\" jaegercfg \"github.com/uber/jaeger-client-go/config\" jaegerlog \"github.com/uber/jaeger-client-go/log\" \"github.com/uber/jaeger-lib/metrics\" ) var ( port = \"8080\" addr = \":8080\" ) func init() { cfg := jaegercfg.Configuration{ Sampler: \u0026jaegercfg.SamplerConfig{ Type: jaeger.SamplerTypeConst, Param: 1, }, Reporter: \u0026jaegercfg.ReporterConfig{ LogSpans: true, }, } _, err := cfg.InitGlobalTracer( \"jaeger-example\", // 服务名 jaegercfg.Logger(jaegerlog.StdLogger), jaegercfg.Metrics(metrics.NullFactory), ) if err != nil { panic(err) } } func main() { engine := gin.New() engine.GET(\"/\", indexHandler) engine.GET(\"/home\", homeHandler) engine.GET(\"/async\", serviceHandler) engine.GET(\"/service\", serviceHandler) engine.GET(\"/db\", dbHandler) engine.Run(addr) } func dbHandler(c *gin.Context) { var sp opentracing.Span opName := c.Request.URL.Path wireContext, err := opentracing.GlobalTracer().Extract( opentracing.TextMap, opentracing.HTTPHeadersCarrier(c.Request.Header)) if err != nil { // 获取失败，则直接新建一个根节点 span sp = opentracing.StartSpan(opName) } else { sp = opentracing.StartSpan(opName, opentracing.ChildOf(wireContext)) } defer sp.Finish() time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond) } func serviceHandler(c *gin.Context) { // 通过http header，提取span元数据信息 var sp opentracing.Span opName := c.Request.URL.Path wireContext, err := opentracing.GlobalTracer().Extract( opentracing.TextMap, opentracing.HTTPHeadersCarrier(c.Request.Header)) if err != nil { // 获取失败，则直接新建一个根节点 span sp = opentracing.StartSpan(opName) } else { sp = opentracing.StartSpan(opName, opentracing.ChildOf(wireContext)) } defer sp.Finish() dbReq, _ := http.NewRequest(\"GET\", \"http://localhost:8080/db\", nil) err = sp.Tracer().Inject(sp.Context(), opentracing.TextMap, opentracing.HTTPHeadersCarrier(dbReq.Header)) if err != nil { log.Fatalf(\"[dbReq]无法添加span context到http header: %v\", err) } if _, err = http.DefaultClient.Do(dbReq); err != nil { sp.SetTag(\"error\", true) sp.LogKV(\"请求 /db error\", err) } time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond) } func homeHandler(c *gin.Context) { c.Header(\"Content-Type\", \"text/html; charset=utf-8\") c.String(200, \"开始请求...\\n\") // 设置一个根节点 span span := opentracing.StartSpan(\"请求 /home\") defer span.Finish() asyncReq, _ := http.NewRequest(\"GET\", \"http://localhost:8080/async\", nil) err := span.Tracer().Inject(span.Context(), opentracing.TextMap, opentracing.HTTPHeadersCarrier(asyncReq.Header)) if err != nil { log.Fatalf(\"[asyncReq]无法添加span context到http header: %v\", err) } go func() { if _, err := http.DefaultClient.Do(asyncReq); err != nil { span.SetTag(\"error\", true) span.LogKV(fmt.Sprintf(\"请求 /async error: %v\", err)) } }() time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond) syncReq, _ := http.NewRequest(\"GET\", \"http://localhost:8080/service\", nil) err = span.Tracer().Inject(span.Context(), opentracing.TextMap, opentracing.HTTPHeadersCarrier(syncReq.Header)) if err != nil { log.Fatalf(\"[syncReq]无法添加span context到http header: %v\", err) } if _, err = http.DefaultClient.Do(syncReq); err != nil { span.SetTag(\"error\", true) span.LogKV(fmt.Sprintf(\"请求 /service error: %v\", err)) } c.String(200, \"请求结束！\") } func indexHandler(c *gin.Context) { c.Header(\"Content-Type\", \"text/html; charset=utf-8\") c.String(200, string(` 点击开始发起请求 `)) } 启动程序，浏览器访问 http://localhost:8080/\n点击链接,访问 Jaeger UI，可以看到刚才的请求链。\n小结 今天就简单介绍了 opentracing 和 使用 Jaeger 进行链路追踪。\n参考链接:\nhttps://rainmakerho.github.io/2019/01/04/2019002/ https://opentracing.io/ ","wordCount":"774","inLanguage":"zh","image":"https://jasminides.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2021-09-18T22:38:37+08:00","dateModified":"2021-09-18T22:38:37+08:00","author":{"@type":"Person","name":"overstarry"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jasminides.com/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E5%88%9D%E6%8E%A2/"},"publisher":{"@type":"Organization","name":"Overstarry Site","logo":{"@type":"ImageObject","url":"https://jasminides.com/img/favicon/favicon.ico"}}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2240998016636586" crossorigin=anonymous></script><link rel=manifest href=/site.webmanifest></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jasminides.com/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jasminides.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://jasminides.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://jasminides.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://jasminides.com/index.xml title=rss><span>rss</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jasminides.com/>主页</a>&nbsp;»&nbsp;<a href=https://jasminides.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">分布式链路追踪初探</h1><div class=post-meta><span title='2021-09-18 22:38:37 +0800 +0800'>九月 18, 2021</span>&nbsp;·&nbsp;overstarry&nbsp;|&nbsp;<a href=https://github.com/overstarry/blogs/blob/master/content/posts/%e5%88%86%e5%b8%83%e5%bc%8f%e9%93%be%e8%b7%af%e8%bf%bd%e8%b8%aa%e5%88%9d%e6%8e%a2.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#opentracing-%e4%bb%8b%e7%bb%8d aria-label="OpenTracing 介绍">OpenTracing 介绍</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b aria-label=数据模型>数据模型</a></li><li><a href=#opentracing-for-go aria-label="OpenTracing for go">OpenTracing for go</a></li></ul></li><li><a href=#jaeger aria-label=Jaeger>Jaeger</a><ul><li><a href=#%e6%9e%b6%e6%9e%84 aria-label=架构>架构</a></li><li><a href=#jaeger-%e9%83%a8%e7%bd%b2 aria-label="Jaeger 部署">Jaeger 部署</a></li><li><a href=#jaeger-%e4%bd%bf%e7%94%a8 aria-label="Jaeger 使用">Jaeger 使用</a></li></ul></li><li><a href=#%e5%b0%8f%e7%bb%93 aria-label=小结>小结</a></li></ul></div></details></div><div class=post-content><p>微服务架构 作为云原生核心技术之一，提倡将单体应用程序(巨石架构)划分成一组小的服务（微服务），服务之间互相协调、互相配合，为用户提供最终价值。</p><p>微服务架构设计中，通常由多个微服务组件组成,有 1) API 网关 ( apisix, kong, traefik ) 负责认证鉴权、负载均衡、限流和静态响应处理; 2) 服务注册发现中心( ZooKeeper、Consul 、ETCD )
,负责服务的注册和发现。3)可观测性 负责日志收集查看的ELK、Loki,负责服务性能指标告警的指标 Metrics 监控 Prometheus, 负责追踪请求的 Tracing
链路追踪。在多个组件的组成下，才能顺利组成一个好的微服务架构。</p><p>今天我就来简单的讲一讲微服务组成中可观测性的分布式链路追踪。</p><h2 id=opentracing-介绍>OpenTracing 介绍<a hidden class=anchor aria-hidden=true href=#opentracing-介绍>#</a></h2><p>OpenTracing是一个新的、开放的分布式追踪标准，用于应用程序和OSS包。有过大规模构建微服务经验的开发者都知道分布式追踪的作用和重要性：每个进程的日志和指标监控都有它们的用武之地，但它们都无法重建事务在分布式系统中传播时的复杂旅程。分布式跟踪就是这些旅程。</p><p>OpenTracing 项目定义了一套分布式追踪的标准，以统一各种分布式追踪系统的实现。OpenTracing 中包含了一套分布式追踪的标准规范，各种语言的 API，以及实现了该标准的编程框架和函数库。</p><p>OpenTracing 提供了平台无关、厂商无关的 API，因此开发者只需要对接 OpenTracing API，无需关心后端采用的到底是什么分布式追踪系统，Jager、Skywalking、LightStep 等都可以无缝切换。</p><h3 id=数据模型>数据模型<a hidden class=anchor aria-hidden=true href=#数据模型>#</a></h3><p>OpenTracing 定义了以下数据模型：</p><p>Trace （调用链）：一个 Trace 代表一个事务或者流程在（分布式）系统中的执行过程。例如来自客户端的一个请求从接收到处理完成的过程就是一个 Trace。</p><p>Span（跨度）：Span 是分布式追踪的最小跟踪单位，一个 Trace 由多段 Span 组成。可以被理解为一次方法调用, 一个程序块的调用, 或者一次 RPC/数据库访问。只要是一个具有完整时间周期的程序访问，都可以被认为是一个
Span。</p><p>SpanContext（跨度上下文）：分布式追踪的上下文信息，包括 Trace id，Span id 以及其它需要传递到下游服务的内容。一个 OpenTracing 的实现需要将 SpanContext 通过某种序列化协议 (Wire
Protocol) 在进程边界上进行传递，以将不同进程中的 Span 关联到同一个 Trace 上。对于 HTTP 请求来说，SpanContext 一般是采用 HTTP header 进行传递的。</p><h3 id=opentracing-for-go>OpenTracing for go<a hidden class=anchor aria-hidden=true href=#opentracing-for-go>#</a></h3><p>接下来 创建 main.go ，实现一个 Web 服务，并在请求流程中使用 OpenTracing API 进行埋点处理。</p><p>code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;math/rand&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/gin-gonic/gin&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/opentracing/opentracing-go&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>port</span> = <span style=color:#e6db74>&#34;8080&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>addr</span> = <span style=color:#e6db74>&#34;:8080&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gin</span>.<span style=color:#a6e22e>New</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span>.<span style=color:#a6e22e>GET</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>indexHandler</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span>.<span style=color:#a6e22e>GET</span>(<span style=color:#e6db74>&#34;/home&#34;</span>, <span style=color:#a6e22e>homeHandler</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span>.<span style=color:#a6e22e>GET</span>(<span style=color:#e6db74>&#34;/async&#34;</span>, <span style=color:#a6e22e>serviceHandler</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span>.<span style=color:#a6e22e>GET</span>(<span style=color:#e6db74>&#34;/service&#34;</span>, <span style=color:#a6e22e>serviceHandler</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span>.<span style=color:#a6e22e>GET</span>(<span style=color:#e6db74>&#34;/db&#34;</span>, <span style=color:#a6e22e>dbHandler</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;http://localhost:%s\n&#34;</span>, <span style=color:#a6e22e>port</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span>.<span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>addr</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>dbHandler</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gin</span>.<span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sp</span> <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>Span</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>opName</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wireContext</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>GlobalTracer</span>().<span style=color:#a6e22e>Extract</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>TextMap</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>HTTPHeadersCarrier</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Header</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 获取失败，则直接新建一个根节点 span</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>StartSpan</span>(<span style=color:#a6e22e>opName</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>StartSpan</span>(<span style=color:#a6e22e>opName</span>, <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>ChildOf</span>(<span style=color:#a6e22e>wireContext</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>Finish</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>(<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#ae81ff>200</span>)) <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>serviceHandler</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gin</span>.<span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 通过http header，提取span元数据信息</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sp</span> <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>Span</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>opName</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wireContext</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>GlobalTracer</span>().<span style=color:#a6e22e>Extract</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>TextMap</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>HTTPHeadersCarrier</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>Header</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 获取失败，则直接新建一个根节点 span</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>StartSpan</span>(<span style=color:#a6e22e>opName</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>StartSpan</span>(<span style=color:#a6e22e>opName</span>, <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>ChildOf</span>(<span style=color:#a6e22e>wireContext</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>Finish</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dbReq</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewRequest</span>(<span style=color:#e6db74>&#34;GET&#34;</span>, <span style=color:#e6db74>&#34;http://localhost:8080/db&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>Tracer</span>().<span style=color:#a6e22e>Inject</span>(<span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>Context</span>(),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>TextMap</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>HTTPHeadersCarrier</span>(<span style=color:#a6e22e>dbReq</span>.<span style=color:#a6e22e>Header</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;[dbReq]无法添加span context到http header: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>DefaultClient</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>dbReq</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>SetTag</span>(<span style=color:#e6db74>&#34;error&#34;</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>LogKV</span>(<span style=color:#e6db74>&#34;请求 /db error&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>(<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#ae81ff>200</span>)) <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>homeHandler</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gin</span>.<span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>String</span>(<span style=color:#ae81ff>200</span>, <span style=color:#e6db74>&#34;开始请求...\n&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 设置一个根节点 span</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>span</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>StartSpan</span>(<span style=color:#e6db74>&#34;请求 /home&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>Finish</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>asyncReq</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewRequest</span>(<span style=color:#e6db74>&#34;GET&#34;</span>, <span style=color:#e6db74>&#34;http://localhost:8080/async&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>Tracer</span>().<span style=color:#a6e22e>Inject</span>(<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>Context</span>(),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>TextMap</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>HTTPHeadersCarrier</span>(<span style=color:#a6e22e>asyncReq</span>.<span style=color:#a6e22e>Header</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;[asyncReq]无法添加span context到http header: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>DefaultClient</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>asyncReq</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>SetTag</span>(<span style=color:#e6db74>&#34;error&#34;</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>LogKV</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;请求 /async error: %v&#34;</span>, <span style=color:#a6e22e>err</span>))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>(<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#ae81ff>200</span>)) <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>syncReq</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewRequest</span>(<span style=color:#e6db74>&#34;GET&#34;</span>, <span style=color:#e6db74>&#34;http://localhost:8080/service&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>Tracer</span>().<span style=color:#a6e22e>Inject</span>(<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>Context</span>(),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>TextMap</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>HTTPHeadersCarrier</span>(<span style=color:#a6e22e>syncReq</span>.<span style=color:#a6e22e>Header</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;[syncReq]无法添加span context到http header: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>DefaultClient</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>syncReq</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>SetTag</span>(<span style=color:#e6db74>&#34;error&#34;</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>LogKV</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;请求 /service error: %v&#34;</span>, <span style=color:#a6e22e>err</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>String</span>(<span style=color:#ae81ff>200</span>, <span style=color:#e6db74>&#34;请求结束！&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>indexHandler</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gin</span>.<span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>String</span>(<span style=color:#ae81ff>200</span>, string(<span style=color:#e6db74>`&lt;a href=&#34;/home&#34;&gt; 点击开始发起请求 &lt;/a&gt;`</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>就这样一个使用 OpenTracing API 进行链路追踪的 web 服务就这样完成了，接下来只需要在应用程序启动时连接到任意实现了 OpenTracing 标准的链路追踪系统即可。</p><h2 id=jaeger>Jaeger<a hidden class=anchor aria-hidden=true href=#jaeger>#</a></h2><p>接下来介绍实现了 OpenTracing API 标准的链路追踪系统 Jaeger。</p><p>Jaeger 受 Dapper 和 OpenZipkin 的启发，是 Uber Technologies 开源的分布式跟踪系统，遵循 OpenTracing 标准，功能包括：</p><ul><li>分布式上下文传播</li><li>监控分布式事务</li><li>执行根原因分析</li><li>服务依赖分析</li><li>优化性能和延迟时间</li></ul><p>Jaeger 是云原生计算基金会( CNCF )毕业项目。</p><h3 id=架构>架构<a hidden class=anchor aria-hidden=true href=#架构>#</a></h3><p>Jaeger可以被部署为一体式二进制，即所有Jaeger后端组件在一个单一进程中运行，也可以被部署为可扩展的分布式系统。</p><h3 id=jaeger-部署>Jaeger 部署<a hidden class=anchor aria-hidden=true href=#jaeger-部署>#</a></h3><p>因为环境所限,就采用最简单的部署方式，下载 jaeger-1.26.0-windows-amd64.tar ,解压。</p><p>进入解压后的文件夹，执行命令行 jaeger-all-in-one &ndash;processor.zipkin-compact.server-host-port=9411。</p><p>然后在浏览器输入 http://localhost:16686/ ，就可以看到 Jaeger UI 。如下图:
<img loading=lazy src=/img/jaeger/img.png alt=img.png></p><h3 id=jaeger-使用>Jaeger 使用<a hidden class=anchor aria-hidden=true href=#jaeger-使用>#</a></h3><p>上面已经成功安装运行 Jaeger 了, 接下来给我们的应用程序接入 Jaeger。</p><p>安装 Jaeger go Client</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go get -u github.com/uber/jaeger-client-go
</span></span></code></pre></div><p>修改后的代码:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;math/rand&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/gin-gonic/gin&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/opentracing/opentracing-go&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/uber/jaeger-client-go&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>jaegercfg</span> <span style=color:#e6db74>&#34;github.com/uber/jaeger-client-go/config&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>jaegerlog</span> <span style=color:#e6db74>&#34;github.com/uber/jaeger-client-go/log&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/uber/jaeger-lib/metrics&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>port</span> = <span style=color:#e6db74>&#34;8080&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>addr</span> = <span style=color:#e6db74>&#34;:8080&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cfg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>jaegercfg</span>.<span style=color:#a6e22e>Configuration</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Sampler</span>: <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>jaegercfg</span>.<span style=color:#a6e22e>SamplerConfig</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Type</span>:  <span style=color:#a6e22e>jaeger</span>.<span style=color:#a6e22e>SamplerTypeConst</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Param</span>: <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Reporter</span>: <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>jaegercfg</span>.<span style=color:#a6e22e>ReporterConfig</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>LogSpans</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cfg</span>.<span style=color:#a6e22e>InitGlobalTracer</span>(
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;jaeger-example&#34;</span>, <span style=color:#75715e>// 服务名</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>jaegercfg</span>.<span style=color:#a6e22e>Logger</span>(<span style=color:#a6e22e>jaegerlog</span>.<span style=color:#a6e22e>StdLogger</span>),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>jaegercfg</span>.<span style=color:#a6e22e>Metrics</span>(<span style=color:#a6e22e>metrics</span>.<span style=color:#a6e22e>NullFactory</span>),
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gin</span>.<span style=color:#a6e22e>New</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span>.<span style=color:#a6e22e>GET</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>indexHandler</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span>.<span style=color:#a6e22e>GET</span>(<span style=color:#e6db74>&#34;/home&#34;</span>, <span style=color:#a6e22e>homeHandler</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span>.<span style=color:#a6e22e>GET</span>(<span style=color:#e6db74>&#34;/async&#34;</span>, <span style=color:#a6e22e>serviceHandler</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span>.<span style=color:#a6e22e>GET</span>(<span style=color:#e6db74>&#34;/service&#34;</span>, <span style=color:#a6e22e>serviceHandler</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span>.<span style=color:#a6e22e>GET</span>(<span style=color:#e6db74>&#34;/db&#34;</span>, <span style=color:#a6e22e>dbHandler</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>engine</span>.<span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>addr</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>dbHandler</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gin</span>.<span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sp</span> <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>Span</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>opName</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wireContext</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>GlobalTracer</span>().<span style=color:#a6e22e>Extract</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>TextMap</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>HTTPHeadersCarrier</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>Header</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 获取失败，则直接新建一个根节点 span</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>StartSpan</span>(<span style=color:#a6e22e>opName</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>StartSpan</span>(<span style=color:#a6e22e>opName</span>, <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>ChildOf</span>(<span style=color:#a6e22e>wireContext</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>Finish</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>(<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#ae81ff>200</span>)) <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>serviceHandler</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gin</span>.<span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 通过http header，提取span元数据信息</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sp</span> <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>Span</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>opName</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wireContext</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>GlobalTracer</span>().<span style=color:#a6e22e>Extract</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>TextMap</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>HTTPHeadersCarrier</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>Header</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 获取失败，则直接新建一个根节点 span</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>StartSpan</span>(<span style=color:#a6e22e>opName</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>StartSpan</span>(<span style=color:#a6e22e>opName</span>, <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>ChildOf</span>(<span style=color:#a6e22e>wireContext</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>Finish</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dbReq</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewRequest</span>(<span style=color:#e6db74>&#34;GET&#34;</span>, <span style=color:#e6db74>&#34;http://localhost:8080/db&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>Tracer</span>().<span style=color:#a6e22e>Inject</span>(<span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>Context</span>(),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>TextMap</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>HTTPHeadersCarrier</span>(<span style=color:#a6e22e>dbReq</span>.<span style=color:#a6e22e>Header</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;[dbReq]无法添加span context到http header: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>DefaultClient</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>dbReq</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>SetTag</span>(<span style=color:#e6db74>&#34;error&#34;</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>LogKV</span>(<span style=color:#e6db74>&#34;请求 /db error&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>(<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#ae81ff>200</span>)) <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>homeHandler</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gin</span>.<span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Header</span>(<span style=color:#e6db74>&#34;Content-Type&#34;</span>, <span style=color:#e6db74>&#34;text/html; charset=utf-8&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>String</span>(<span style=color:#ae81ff>200</span>, <span style=color:#e6db74>&#34;开始请求...\n&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 设置一个根节点 span</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>span</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>StartSpan</span>(<span style=color:#e6db74>&#34;请求 /home&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>Finish</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>asyncReq</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewRequest</span>(<span style=color:#e6db74>&#34;GET&#34;</span>, <span style=color:#e6db74>&#34;http://localhost:8080/async&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>Tracer</span>().<span style=color:#a6e22e>Inject</span>(<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>Context</span>(),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>TextMap</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>HTTPHeadersCarrier</span>(<span style=color:#a6e22e>asyncReq</span>.<span style=color:#a6e22e>Header</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;[asyncReq]无法添加span context到http header: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>DefaultClient</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>asyncReq</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>SetTag</span>(<span style=color:#e6db74>&#34;error&#34;</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>LogKV</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;请求 /async error: %v&#34;</span>, <span style=color:#a6e22e>err</span>))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>(<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#ae81ff>200</span>)) <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>syncReq</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewRequest</span>(<span style=color:#e6db74>&#34;GET&#34;</span>, <span style=color:#e6db74>&#34;http://localhost:8080/service&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>Tracer</span>().<span style=color:#a6e22e>Inject</span>(<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>Context</span>(),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>TextMap</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>opentracing</span>.<span style=color:#a6e22e>HTTPHeadersCarrier</span>(<span style=color:#a6e22e>syncReq</span>.<span style=color:#a6e22e>Header</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;[syncReq]无法添加span context到http header: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>DefaultClient</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>syncReq</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>SetTag</span>(<span style=color:#e6db74>&#34;error&#34;</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>LogKV</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;请求 /service error: %v&#34;</span>, <span style=color:#a6e22e>err</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>String</span>(<span style=color:#ae81ff>200</span>, <span style=color:#e6db74>&#34;请求结束！&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>indexHandler</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gin</span>.<span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Header</span>(<span style=color:#e6db74>&#34;Content-Type&#34;</span>, <span style=color:#e6db74>&#34;text/html; charset=utf-8&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>String</span>(<span style=color:#ae81ff>200</span>, string(<span style=color:#e6db74>`&lt;a href=&#34;/home&#34;&gt; 点击开始发起请求 &lt;/a&gt;`</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>启动程序，浏览器访问 http://localhost:8080/</p><p><img loading=lazy src=/img/jaeger/img_1.png alt=img_1.png>
点击链接,访问 Jaeger UI，可以看到刚才的请求链。</p><p><img loading=lazy src=/img/jaeger/img_2.png alt=img_2.png></p><h2 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h2><p>今天就简单介绍了 opentracing 和 使用 Jaeger 进行链路追踪。</p><p>参考链接:</p><ul><li><a href=https://rainmakerho.github.io/2019/01/04/2019002/>https://rainmakerho.github.io/2019/01/04/2019002/</a></li><li><a href=https://opentracing.io/>https://opentracing.io/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jasminides.com/tags/opentracing/>OpenTracing</a></li><li><a href=https://jasminides.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/>分布式链路追踪</a></li></ul><nav class=paginav><a class=prev href=https://jasminides.com/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E5%88%9D%E6%8E%A22/><span class=title>« 上一页</span><br><span>分布式链路追踪初探2</span>
</a><a class=next href=https://jasminides.com/posts/%E9%81%8D%E5%8E%86map%E5%88%97%E8%A1%A8%E7%9A%84golang%E6%A8%A1%E6%9D%BF/><span class=title>下一页 »</span><br><span>遍历map列表的Golang模板</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 分布式链路追踪初探 on x" href="https://x.com/intent/tweet/?text=%e5%88%86%e5%b8%83%e5%bc%8f%e9%93%be%e8%b7%af%e8%bf%bd%e8%b8%aa%e5%88%9d%e6%8e%a2&amp;url=https%3a%2f%2fjasminides.com%2fposts%2f%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E9%2593%25BE%25E8%25B7%25AF%25E8%25BF%25BD%25E8%25B8%25AA%25E5%2588%259D%25E6%258E%25A2%2f&amp;hashtags=OpenTracing%2c%e5%88%86%e5%b8%83%e5%bc%8f%e9%93%be%e8%b7%af%e8%bf%bd%e8%b8%aa"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 分布式链路追踪初探 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjasminides.com%2fposts%2f%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E9%2593%25BE%25E8%25B7%25AF%25E8%25BF%25BD%25E8%25B8%25AA%25E5%2588%259D%25E6%258E%25A2%2f&amp;title=%e5%88%86%e5%b8%83%e5%bc%8f%e9%93%be%e8%b7%af%e8%bf%bd%e8%b8%aa%e5%88%9d%e6%8e%a2&amp;summary=%e5%88%86%e5%b8%83%e5%bc%8f%e9%93%be%e8%b7%af%e8%bf%bd%e8%b8%aa%e5%88%9d%e6%8e%a2&amp;source=https%3a%2f%2fjasminides.com%2fposts%2f%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E9%2593%25BE%25E8%25B7%25AF%25E8%25BF%25BD%25E8%25B8%25AA%25E5%2588%259D%25E6%258E%25A2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 分布式链路追踪初探 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjasminides.com%2fposts%2f%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E9%2593%25BE%25E8%25B7%25AF%25E8%25BF%25BD%25E8%25B8%25AA%25E5%2588%259D%25E6%258E%25A2%2f&title=%e5%88%86%e5%b8%83%e5%bc%8f%e9%93%be%e8%b7%af%e8%bf%bd%e8%b8%aa%e5%88%9d%e6%8e%a2"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 分布式链路追踪初探 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjasminides.com%2fposts%2f%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E9%2593%25BE%25E8%25B7%25AF%25E8%25BF%25BD%25E8%25B8%25AA%25E5%2588%259D%25E6%258E%25A2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 分布式链路追踪初探 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%88%86%e5%b8%83%e5%bc%8f%e9%93%be%e8%b7%af%e8%bf%bd%e8%b8%aa%e5%88%9d%e6%8e%a2%20-%20https%3a%2f%2fjasminides.com%2fposts%2f%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E9%2593%25BE%25E8%25B7%25AF%25E8%25BF%25BD%25E8%25B8%25AA%25E5%2588%259D%25E6%258E%25A2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 分布式链路追踪初探 on telegram" href="https://telegram.me/share/url?text=%e5%88%86%e5%b8%83%e5%bc%8f%e9%93%be%e8%b7%af%e8%bf%bd%e8%b8%aa%e5%88%9d%e6%8e%a2&amp;url=https%3a%2f%2fjasminides.com%2fposts%2f%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E9%2593%25BE%25E8%25B7%25AF%25E8%25BF%25BD%25E8%25B8%25AA%25E5%2588%259D%25E6%258E%25A2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 分布式链路追踪初探 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e5%88%86%e5%b8%83%e5%bc%8f%e9%93%be%e8%b7%af%e8%bf%bd%e8%b8%aa%e5%88%9d%e6%8e%a2&u=https%3a%2f%2fjasminides.com%2fposts%2f%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E9%2593%25BE%25E8%25B7%25AF%25E8%25BF%25BD%25E8%25B8%25AA%25E5%2588%259D%25E6%258E%25A2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=overstarry/overstarry.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkzODMwMDQ3ODg=" data-category-id=DIC_kwDOFtQwdM4B-Q5w data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>Copyright © 2024 - overstarry · All rights reserved<br></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>