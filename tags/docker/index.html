<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker | Overstarry Site</title>
<meta name=keywords content><meta name=description content="overstarry site"><meta name=author content="overstarry"><link rel=canonical href=https://jasminides.com/tags/docker/><meta name=google-site-verification content="gfdsdx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://jasminides.com/img/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jasminides.com/img/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jasminides.com/img/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://jasminides.com/img/favicon/apple-touch-icon.png><link rel=mask-icon href=https://jasminides.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jasminides.com/tags/docker/index.xml><link rel=alternate hreflang=zh href=https://jasminides.com/tags/docker/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-G40XG2SPQN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G40XG2SPQN")}</script><meta property="og:title" content="Docker"><meta property="og:description" content="overstarry site"><meta property="og:type" content="website"><meta property="og:url" content="https://jasminides.com/tags/docker/"><meta property="og:image" content="https://jasminides.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="overstarry site"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jasminides.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Docker"><meta name=twitter:description content="overstarry site"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2240998016636586" crossorigin=anonymous></script><link rel=manifest href=/site.webmanifest></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jasminides.com/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jasminides.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://jasminides.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://jasminides.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://jasminides.com/index.xml title=rss><span>rss</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://jasminides.com/>主页</a>&nbsp;»&nbsp;<a href=https://jasminides.com/tags/>Tags</a></div><h1>Docker</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Docker Desktop 设置网络代理</h2></header><div class=entry-content><p>前言 最近遇到 Docker Desktop 构建 node 项目时，由于网络问题导致的构建失败问题，本文将介绍两个给 Docker Desktop 设置网络代理的方法。
修改 WSL2 配置 为了测试代理的效果，这里创建一个go服务，代码很简单，就是访问 https://www.google.com/ 并返回结果。如果能正常访问，说明代理设置成功。
package main import "net/http" func main() { resp, err := http.Get("https://www.google.com/") if err != nil { panic(err) } defer resp.Body.Close() println(resp.Status) } 第一种方法是修改 WSL2 的配置，在 windows C:\Users&lt;your_username> 目录下创建 .wslconfig 文件，输入以下内容:
[experimental] autoMemoryReclaim=gradual networkingMode=mirrored dnsTunneling=true firewall=true autoProxy=true 然后重启 WSL: wsl --shutdown
networkingMode 为mirrored 表示网络模式使用镜像模式，会镜像宿主机的网络设置，能更好的集成宿主机和WSL的网络。
autoProxy 开启了自动代理的功能，意味 WSL 自动配置代理设置。
配置好，我们构建 Docker 镜像，运行:
可以看到代理成功生效，可以正常访问。
接下来介绍通过修改 Docker Desktop 的配置文件，设置代理。
修改 Docker Desktop 配置 打开 Docker Desktop 的设置，找到 Resources Proxies 选项，设置代理。
...</p></div><footer class=entry-footer><span title='2024-09-21 15:12:23 +0800 +0800'>九月 21, 2024</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Docker Desktop 设置网络代理" href=https://jasminides.com/posts/docker-desktop-proxy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>docker init 命令</h2></header><div class=entry-content><p>前言 Docker 是一个广受欢迎的开发平台，它允许用户通过容器化技术来构建、打包和部署应用程序。尽管 Docker 提供了强大的功能和灵活性，但对于初学者而言，在项目中配置 Docker 可能会遇到一些挑战。
不过，Docker 官方为了降低使用门槛，推出了一个便捷的命令docker init。这个命令旨在快速初始化 Docker 配置，从而简化将 Docker 集成到项目中的流程。通过使用这个命令，用户可以轻松地为项目设置必要的 Docker 支持，进而享受到 Docker 带来的便利和效率提升。
docker init 简介 docker init 命令会根据用户指定的选项生成运行容器的一些文件，极大的加快了项目的容器化:
.dockerignore : docker 构建时忽略的文件列表 Dockerfile: 镜像的核心文件 Compose.yaml: docker compose 的配置文件 README.Docker.md 如果你的项目中已有以上文件，会让你选择是否覆盖旧文件避免文件冲突问题。
docker init 提供了一组项目的模板文件，包括了 Go、Python、ASP.NET Core等常见的服务器应用程序及一个其它类型应用程序模板。开发者使用 init 命令时，可以根据选择的模板生成相应的文件，使开发者可以快速的构建并启动容器。
使用 接下来介绍如何使用 docker init 进行项目容器的初始化，这里以前文的go项目为例子进行介绍。
进入项目根目录执行 init 命令,选择go模板,会让你选择使用的go版本,主程序的位置及应用所使用的端口: 执行完可以看到会生成相应的文件及如何构建并运行的命令。
查看生成的Dockerfile 和 Compose.yaml文件:
# syntax=docker/dockerfile:1 # Comments are provided throughout this file to help you get started. # If you need more help, visit the Dockerfile reference guide at # https://docs.docker.com/go/dockerfile-reference/ # Want to help us make this template better? Share your feedback here: https://forms.gle/ybq9Krt8jtBL3iCk7 ################################################################################ # Create a stage for building the application. ARG GO_VERSION=1.21.0 FROM --platform=$BUILDPLATFORM golang:${GO_VERSION} AS build WORKDIR /src # Download dependencies as a separate step to take advantage of Docker's caching. # Leverage a cache mount to /go/pkg/mod/ to speed up subsequent builds. # Leverage bind mounts to go.sum and go.mod to avoid having to copy them into # the container. RUN --mount=type=cache,target=/go/pkg/mod/ \ --mount=type=bind,source=go.sum,target=go.sum \ --mount=type=bind,source=go.mod,target=go.mod \ go mod download -x # This is the architecture you’re building for, which is passed in by the builder. # Placing it here allows the previous steps to be cached across architectures. ARG TARGETARCH # Build the application. # Leverage a cache mount to /go/pkg/mod/ to speed up subsequent builds. # Leverage a bind mount to the current directory to avoid having to copy the # source code into the container. RUN --mount=type=cache,target=/go/pkg/mod/ \ --mount=type=bind,target=. \ CGO_ENABLED=0 GOARCH=$TARGETARCH go build -o /bin/server ./retry/server ################################################################################ # Create a new stage for running the application that contains the minimal # runtime dependencies for the application. This often uses a different base # image from the build stage where the necessary files are copied from the build # stage. # # The example below uses the alpine image as the foundation for running the app. # By specifying the "latest" tag, it will also use whatever happens to be the # most recent version of that image when you build your Dockerfile. If # reproducability is important, consider using a versioned tag # (e.g., alpine:3.17.2) or SHA (e.g., alpine@sha256:c41ab5c992deb4fe7e5da09f67a8804a46bd0592bfdf0b1847dde0e0889d2bff). FROM alpine:latest AS final # Install any runtime dependencies that are needed to run your application. # Leverage a cache mount to /var/cache/apk/ to speed up subsequent builds. RUN --mount=type=cache,target=/var/cache/apk \ apk --update add \ ca-certificates \ tzdata \ && \ update-ca-certificates # Create a non-privileged user that the app will run under. # See https://docs.docker.com/go/dockerfile-user-best-practices/ ARG UID=10001 RUN adduser \ --disabled-password \ --gecos "" \ --home "/nonexistent" \ --shell "/sbin/nologin" \ --no-create-home \ --uid "${UID}" \ appuser USER appuser # Copy the executable from the "build" stage. COPY --from=build /bin/server /bin/ # Expose the port that the application listens on. EXPOSE 9000 # What the container should run when it is started. ENTRYPOINT [ "/bin/server" ] 可以看到 Dockerfile 是一个常见的多阶段构建镜像流程。
...</p></div><footer class=entry-footer><span title='2024-04-13 23:26:38 +0800 +0800'>四月 13, 2024</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to docker init 命令" href=https://jasminides.com/posts/docker_init_command/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Containerd本地调试环境搭建</h2></header><div class=entry-content><p>最近在学习常用的容器运行时 containerd, 本篇我就来介绍如何本地构建 containerd 进行调试开发，主要介绍2种 常规方式和使用容器构建，由于本地环境限制，我主要是使用 docker 搭建本地调试环境。
非容器 build 这里先开始介绍常规直接从源码本地构建的方式。
构建环境要求 1 go1.19.x及以上版本
2 Protoc 3.x+
3 适用于您的发行版的 Btrfs 标头和库。请注意，可以通过构建标签禁用构建 btrfs 驱动程序no_btrfs，从而删除此依赖项。
前面2点相信大家都很清楚，第三点的 Btrfs 是什么呢？Btrfs是一种现代的Linux写时复制（COW）文件系统，旨在实现先进的功能，同时也注重容错、修复和简易管理。
build 1 拉取containerd 源代码至本地
2 构建
进入源代码根目录，执行一下命令:
cd containerd make 执行后，会在 ./bin/ 目录下生成所有项目的二进制文件。
如果你需要修改 gRPC API ,修改后需要使用 protoc 编译生成新的代码: make generate
docker 容器构建 接下来讲解怎么通过 docker 构建本地 containerd 调试环境。
构建要求 1 go1.19.x及以上版本
2 Protoc 3.x+
3 docker
构建 进入源代码根目录 cd containerd， 执行以下命令:
docker run -it -v ${PWD}/containerd:/go/src/github.com/containerd/containerd -e GOPATH=/go -w /go/src/github.com/containerd/containerd golang:1.19 make && make install 这将会进行 containerd 的构建，过了一会发现构建失败,错误信息如下:
...</p></div><footer class=entry-footer><span title='2023-02-19 00:43:59 +0800 +0800'>二月 19, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Containerd本地调试环境搭建" href=https://jasminides.com/posts/containerd%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>容器出现时间异常问题及解决方法</h2></header><div class=entry-content><p>问题 最近在使用 MinIO SDK 上传资源对象时, 出现了一个问题: The difference between the request time and the server's time is too large. 从错误信息可以看出客户端上传资源的时间与 Minio server 的时间相差太大, 导致资源上传失败。
解决 根据错误信息得出 server 端的时间出现异常, 由于我采用容器部署的方式, 因此可以先查看容器的时间是否正确。
进入 Minio 容器 , 执行命令: date, 可以看到如图结果( UTC 时间): 而目前的时间是( CST 时间) :
可以看出容器的时间与实际的时间相差太大, 所以导致资源上传失败。
方法1 出现了时间异常的问题, 可能很多人第一反应就是调整容器的时间，通过 ntpdate 等工具调整时间, 这种解决方法方法适用于非容器的 MinIO SERVER 环境调整时间，容器因为一些限制无法使用此方法。
方法2 在网上查看了许多相关的问题，有了一个针对容器的解决方法，执行:
docker run --rm --privileged alpine hwclock -s 可以看到容器时间已经正常了:
我对这条命令不太明白，不明白为什么会影响到其它运行中的容器, 可能是与 docker for win 的一些容器实现机制相关。
...</p></div><footer class=entry-footer><span title='2021-11-12 09:33:31 +0800 +0800'>十一月 12, 2021</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to 容器出现时间异常问题及解决方法" href=https://jasminides.com/posts/%E5%AE%B9%E5%99%A8%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Docker_grafana启动失败</h2></header><div class=entry-content><p>Docker grafana 启动失败 今天在使用 Docker 启动 grafana 的时候, 遇到了一个问题， 问题如图: 为什么会出现这个问题 根据错误日志的提示, 打开 http://docs.grafana.org/installation/docker/#migrate-to-v51-or-later 网址, 根据官方的描述，grafana Docker镜像在版本5.1及以后有了重大改变:
* 在容器启动过程中不会改变文件的权限 * 默认用户ID由104 变为 472 * 删除了以下的隐式卷: * /var/lib/grafana * /etc/grafana * /var/log/grafana 解决 根据官方文档的提示，我仔细查看了我的 compose 文件， 发现我加了 user: ‘104’ , 应该是此行的原因导致 grafana 没有启动成功， 删除此行，顺利启动。</p></div><footer class=entry-footer><span title='2021-08-12 10:56:32 +0800 +0800'>八月 12, 2021</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Docker_grafana启动失败" href=https://jasminides.com/posts/docker_grafana%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Nginx搭建静态图片资源服务器</h2></header><div class=entry-content><p>Nginx搭建静态图片资源服务器 本文介绍使用 Docker Nginx 搭建静态图片资源服务器的过程和搭建中间遇到的问题。
我使用 Docker compose 搭建静态图片资源服务器， 我使用的 compose 文件内容如下：
version: '3.1' services: nginx: restart: always image: nginx container_name: asset ports: - 80:80 volumes: - ./nginx.conf:/etc/nginx/nginx.conf - ./uploads:/usr/share/nginx/uploads - ./conf.d:/etc/nginx/conf.d /srv/msg/storage/uploads:/usr/share/nginx/uploads 将本地的图片文件夹挂载到容器内的 /usr/share/nginx/uploads 文件夹 nginx.conf 是 Nginx 的主配置文件， conf.d 是各个网站配置的文件夹。 我的 nginx.conf 内容如下:
user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; include /etc/nginx/conf.d/*.conf; server { listen 80 default_server; listen [::]:80 default_server; server_name 192.168.1.117; root /usr/share/nginx/uploads/; location /{ autoindex on; } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } } 静态资源图片服务器的配置文件如下:
...</p></div><footer class=entry-footer><span title='2021-08-06 16:20:16 +0800 +0800'>八月 6, 2021</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Nginx搭建静态图片资源服务器" href=https://jasminides.com/posts/nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Traefik入门使用</h2></header><div class=entry-content><p>Traefik 入门使用 简介 Traefik（发音为traffic）是一个现代HTTP反向代理和负载均衡设施，使部署微服务变得容易。Traefik与你现有的基础设施组件（Docker、Swarm模式、Kubernetes、Consul、Etcd、…）集成，并自动和动态地配置自己。将Traefik 指向你的基础设施组件应该是你唯一需要的配置步骤。
快速入门 在这里我使用 Docker 来快速使用 Traefik 。
先创建一个 docker-compose.yml 文件，写入如下内容： version: '3' services: reverse-proxy: # 使用的 traefik2.4 Docker镜像版本 image: traefik:v2.4 # 通过命令行参数启动 traefik,启用不安全模式以使用dashboard,配置发现使用了docker command: --api.insecure=true --providers.docker ports: # The HTTP port - "80:80" # dashboard端口 - "8080:8080" volumes: # 监听docker事件 - /var/run/docker.sock:/var/run/docker.sock 执行 docker-compose up -d reverse-proxy 启动 docker-compose up -d reverse-proxy 打开浏览器输入 http://localhost:8080/api/rawdata 访问看见 Traefik’s API rawdata，就表示安装成功了。
打开浏览器输入 http://localhost:8080/dashboard#/ 可以看到由Traefik官方提供的简易的dashboard页面 我们继续来操作，在前面创建的 docker-compose.yml 中继续写入以下内容。
whoami: image: traefik/whoami labels: - "traefik.http.routers.whoami.rule=PathPrefix(`/whoami`)" 执行 docker-compose up -d whoami
...</p></div><footer class=entry-footer><span title='2021-08-06 14:42:43 +0800 +0800'>八月 6, 2021</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Traefik入门使用" href=https://jasminides.com/posts/traefik%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Gitlab CI构建docker镜像</h2></header><div class=entry-content><p>Gitlab CI构建docker镜像 利用Gitlab CI结合Docker构建docker镜像主要有三种方法.
将 Docker 执行器与 Docker 镜像一起使用. 使用 shell 执行器 Docker socket 绑定 现在来讲讲我的具体使用过程和遇到的一些问题，由于我的gitlab-runners使用了docker执行器，所以我主要使用了1和3两种方法。
由于网上的相关文章主要是采用 Docker in Docker 的方式，所以最开始我也是采用这种方式。 我的ci脚本是：
services: - docker:dind variables: OUTPUT_NAME: bot DOCKER_HOST: tcp://localhost:2375 DOCKER_DRIVER: overlay2 DOCKER_TLS_CERTDIR: "" build_docker_image_and_push_to_nexus: stage: build image: docker:stable extends: .go-cache script: - docker info - docker build -t docker.overtsarry.vip/bot:1.0.1 . - docker login --username=$username docker.overtsarry.vip --password $pwd - docker push docker.overtsarry.vip/bot:1.0.1 运行CI，发现CI运行失败，具体报错是
Cannot connect to the Docker daemon at tcp://localhost:2375. Is the docker daemon running? 没有发现docker daemon运行，由于gitlab doc宕机了，在网上又看了一些文章，根据那些文章进行了十几次的修改，还是没有运行成功。后来查看gitlab相关文档，发现docker需要在privileged下运行。(The Docker image has all of the docker tools installed and can run the job script in context of the image in privileged mode.) 就需要修改gitlab-runners的配置文件，设置privileged = true即可。 修改完配置文件，再次运行CI，docker镜像顺利构建上传。 使用Docker in Docker构建成功后，我还顺便尝试使用Docker socket 绑定来构建docker镜像。 这次有了文档辅助进度快了许多，具体的流程:
...</p></div><footer class=entry-footer><span title='2021-07-22 12:44:00 +0800 +0800'>七月 22, 2021</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Gitlab CI构建docker镜像" href=https://jasminides.com/posts/gitlab-ci%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F/></a></article></main><footer class=footer><span>Copyright © 2024 - overstarry · All rights reserved<br></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>