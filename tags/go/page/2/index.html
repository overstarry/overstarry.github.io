<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go | Overstarry Site</title><meta name=keywords content><meta name=description content="overstarry site"><meta name=author content="overstarry"><link rel=canonical href=https://jasminides.com/tags/go/><meta name=google-site-verification content="gfdsdx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://jasminides.com/img/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jasminides.com/img/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jasminides.com/img/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://jasminides.com/img/favicon/apple-touch-icon.png><link rel=mask-icon href=https://jasminides.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jasminides.com/tags/go/index.xml><link rel=alternate hreflang=zh href=https://jasminides.com/tags/go/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-G40XG2SPQN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G40XG2SPQN")}</script><meta property="og:url" content="https://jasminides.com/tags/go/"><meta property="og:site_name" content="Overstarry Site"><meta property="og:title" content="Go"><meta property="og:description" content="overstarry site"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://jasminides.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jasminides.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Go"><meta name=twitter:description content="overstarry site"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2240998016636586" crossorigin=anonymous></script><link rel=manifest href=/site.webmanifest></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jasminides.com/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jasminides.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://www.overstarry.com/ title=game><span>game</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://pokemon.jasminides.com/ title=game><span>game</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://jasminides.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://jasminides.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://jasminides.com/index.xml title=rss><span>rss</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://jasminides.com/>主页</a>&nbsp;»&nbsp;<a href=https://jasminides.com/tags/>Tags</a></div><h1>Go</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Go 设计模式 - 策略模式</h2></header><div class=entry-content><p>今天介绍一个常见的设计模式 - 策略模式，并基于一个简单的例子来讲解。
策略模式介绍 策略模式（Strategy Pattern）是一种行为型设计模式，它将一组算法封装成独立的对象，并使它们可以互相替换。这样做的好处是，可以在运行时动态地改变对象的行为，而不需要修改使用该对象的代码。
何时可以使用策略模式呢 我们在用 GO 编程的时候经常碰到多层控制语句，一层又一层，既不优雅，也不利于后续维护。比如下述这种：
if xxx { // do something } else if xxx { // do something } else if xxx { // do something else { } 虽然按这种模式写起来简单快捷，但它也违背了面向对象的两个原则：
单一职责原则：多个控制语句，意味着拥有多种功能； 开闭原则：当要进行修改时，原有代码不可避免要被修改； 此时就可以采用策略模式来替换这类多层控制语句。
go 实现策略模式 go 语言该怎么实现策略模式呢？
在 Go 语言中，策略模式可以通过接口和函数来实现。首先，我们定义一个接口，该接口声明了算法执行的方法。然后，我们可以为每个具体的算法实现一个结构体，并实现接口中的方法。最后，我们可以在需要使用算法的地方，通过接口来调用具体的算法。
下面通过一个简单的例子来讲解策略模式，现在有这样一个场景我们现在有 2 个数据表，这 2 个数据表拥有相同的字段，都可以根据 name 来查询某个数据，我们需要根据参数的不同来决定使用哪种表进行查询，在没有使用策略模式时，我们往往使用大量的 if 来实现这个操作。 接下来由我来介绍策略模式来实现相同的操作。
先定义查询操作的接口：
type DataStrategy interface { Query(name string) } 定义 2 张表的查询 struct，并实现 DataStrategy 接口：
// table1 通过 table1 来查询 type table1 struct{} func (s *table1) Query(name string) { fmt.Println("table1 query") } // table2 type table2 struct{} func (s *table2) Query(name string) { fmt.Println("table2 query") } 再定义 Data 对象用来执行不同的策略：
...</p></div><footer class=entry-footer><span title='2023-11-11 17:29:39 +0800 +0800'>十一月 11, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 设计模式 - 策略模式" href=https://jasminides.com/posts/go_design-patterns_strategy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Go1.22 新循环语义</h2></header><div class=entry-content><p>前言 前段时间看到了一个提案，是关于 go for 循环的一个提案，根据提案看到了去年 rsc 在社区发出的讨论，讨论的内容主要是为了解决 for 循环变量的问题，是什么样的问题呢，常见的例子如下：
var all []*Item for _, item := range items { all = append(all, &amp;item) } 这段代码有一个问题，循环结束后，all 的内容是包含了 len(all) 个相同的指针，指针指向迭代的最后一个 item。为什么会发生这种情况呢，因为 item 变量是每个循环的而不是每次迭代的，&amp;item 每次迭代都是相同的，并且每次迭代都会被覆盖。 怎么解决呢，最简单的方法就是添加 item := item 这段代码：
var all []*Item for _, item := range items { item := item all = append(all, &amp;item) } 我在使用 Goroutine 协程时也经常遇到这种问题。这种错误已导致许多公司出现生产问题，包括 Lets Encrypt 公开记录的问题。
go 社区为了解决这个问题，打算将循环变量改为每次迭代，即隐式的添加上面的代码。由于其它一些原因，直到今年的 6 月才正式决定在 go 1.21 中添加 GOEXPERIMENT=loopvar 进行相应的尝试，并且将在 go1.22 版本中正式推出。 为了确保与现有代码的向后兼容性，新语义将仅适用于声明 go 1.22 或稍后在其 go.mod 文件中声明的模块中包含的包。
特性测试 我们通过不同版本运行的结果来对比
package main import "fmt" func main() { var prints []func() for _, v := range []int{1, 2, 3} { prints = append(prints, func() { fmt.Println(v) }) } for _, print := range prints { print() } } 没使用旧版本运行的结果是：
...</p></div><footer class=entry-footer><span title='2023-11-04 22:54:05 +0800 +0800'>十一月 4, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go1.22 新循环语义" href=https://jasminides.com/posts/go1.22_new_for_loop/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Go WSDL</h2></header><div class=entry-content><p>最近在实现一个功能时需要使用第三方的接口，由于第三方只提供了一个 WSDL 文件的链接，于是研究了 golang 如何解析 WSDL 并调用相应接口，本文就是介绍 WSDL 和 go 如何解析并调用。
WSDL 介绍 WSDL 是 Web Services Description Language（Web 服务描述语言）的缩写。它是一种用于描述基于 Web 服务的通信协议和消息格式的 XML 格式语言。
WSDL 被广泛用于描述 Web 服务的接口和操作。它定义了 Web 服务所提供的功能、方法、参数、数据类型以及与服务进行交互的方式。通过 WSDL 文件，客户端应用程序可以了解如何与特定的 Web 服务进行通信。
WSDL 文件通常包含以下几个主要部分：
服务定义：描述了 Web 服务的名称、命名空间和位置。 类型定义：定义了 Web 服务中使用的数据类型，例如字符串、整数等。 消息定义：定义了 Web 服务中使用的消息格式，包括输入和输出消息。 操作定义：定义了 Web 服务的操作或方法，包括输入和输出消息以及相关的参数。 绑定定义：定义了 Web 服务使用的通信协议和消息格式，例如 SOAP（Simple Object Access Protocol）和 HTTP（Hypertext Transfer Protocol）。 服务定义：将服务、绑定和端口等部分组合在一起，定义了 Web 服务的完整描述。 使用 WSDL，开发人员可以生成客户端代码，使其能够与 Web 服务进行交互。客户端可以根据 WSDL 文件了解 Web 服务的结构和可用方法，以便正确地构造请求和解析响应。
总之，WSDL 是一种用于描述 Web 服务接口和操作的语言，它提供了一种标准化的方式来描述和访问 Web 服务。
...</p></div><footer class=entry-footer><span title='2023-09-23 14:17:03 +0800 +0800'>九月 23, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go WSDL" href=https://jasminides.com/posts/go-wdsl/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>playwright-go 浏览器截图</h2></header><div class=entry-content><p>以前的文章介绍了 chromedp 进行浏览器网页截图，这次介绍一种新的网页截图的方法——即使用 playwright 进行浏览器网页截图。
playwright 介绍 Playwright 是一个用于自动化浏览器操作的开源工具集。它由微软开发并于 2020 年发布，旨在提供一种跨浏览器、跨平台的解决方案，可用于测试 Web 应用程序、编写爬虫、执行自动化任务等。
Playwright 支持多种主流浏览器，包括 Chrome、Firefox、Safari 和 Edge，它提供了一组简单易用的 API，可以模拟用户与 Web 页面的交互行为，例如点击、填写表单、导航等。与其他类似工具相比，Playwright 的一个重要特点是它的跨浏览器支持，这意味着你可以使用相同的代码在不同浏览器上运行你的自动化任务，而不需要为每个浏览器单独编写代码。
Playwright 还提供了强大的调试功能，可以帮助开发人员在自动化过程中定位和解决问题。它支持截图和录制操作，使得调试变得更加直观和高效。
另外，Playwright 还具有一些高级功能，例如可以模拟不同的设备、网络环境和地理位置，以及支持并发执行多个浏览器实例等，这些功能使得它在编写复杂的自动化任务时非常有用。
由于我日常主要使用 go 语言进行开发，所以本文的内容主要以 playwright 的 go 模块 playwright-go 为主要介绍。
安装 go get -u github.com/playwright-community/playwright-go 安装相关浏览器和操作系统依赖项：
go run github.com/playwright-community/playwright-go/cmd/playwright@latest install --with-deps # Or go install github.com/playwright-community/playwright-go/cmd/playwright@latest playwright install --with-deps 也可以在代码中使用以下代码安装：err := playwright.Install()
通过安装截图可以看出安装了 3 大主流浏览器和 ffmpeg。
例子 接下来我们看一个官方的例子，从 Hacker News 中抓取当前投票最高的项目。
package main import ( "fmt" "log" "github.com/playwright-community/playwright-go" ) func main() { pw, err := playwright.Run() if err != nil { log.Fatalf("could not start playwright: %v", err) } browser, err := pw.Chromium.Launch() if err != nil { log.Fatalf("could not launch browser: %v", err) } page, err := browser.NewPage() if err != nil { log.Fatalf("could not create page: %v", err) } if _, err = page.Goto("https://news.ycombinator.com"); err != nil { log.Fatalf("could not goto: %v", err) } entries, err := page.Locator(".athing").All() if err != nil { log.Fatalf("could not get entries: %v", err) } for i, entry := range entries { title, err := entry.Locator("td.title > span > a").TextContent() if err != nil { log.Fatalf("could not get text content: %v", err) } fmt.Printf("%d: %s\n", i+1, title) } if err = browser.Close(); err != nil { log.Fatalf("could not close browser: %v", err) } if err = pw.Stop(); err != nil { log.Fatalf("could not stop Playwright: %v", err) } } ...</p></div><footer class=entry-footer><span title='2023-09-02 17:33:33 +0800 +0800'>九月 2, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to playwright-go 浏览器截图" href=https://jasminides.com/posts/playwright-go%E7%AE%80%E4%BB%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>gonew 介绍</h2></header><div class=entry-content><p>前几周。在关注的 go 提案每周会议中，发现了一条比较感兴趣的内容：gonew: templates for new modules ,通过标题可以猜到 gonew 应该是一个通过配置项目模板生成新项目的模块。
通过对 discussions 中 rsc 所描述的内容进行分析，可以得知为什么要启动这么一个新项目: go 团队经常收到用户的请求，想要通过模板启动一个新项目，即以某种基本的项目模板来创建一个新 Go module。Russ 私下编写了一个实现这个功能的小工具:rsc.io/tmp/gonew. Russ 在 google 内部宣传该工具后，Google 内部的一些团队便定制了一些模板 (template) ，尤其是 ServiceWeaver 团队的响应尤为积极。这一切最终让 Russ 决定引入 golang.org/x/tools/cmd/gonew。 gonew 工具的引入大幅简化了 Go 项目的创建，同时由于对自定义项目模板的支持，也可以提高 Go 项目的标准化水平。目前 gonew 工具是实验性的，后续可能会增加新的特性，但目前的核心功能是会保留的。
通过对 discussions 中社区用户开发着的回应可以看出，大家纷纷讲述了没有 gonew 前所使用的工具，并对 gonew 建言献策，可以看出大部分的开发者都十分欢迎这个新功能的。
接下来就由我来介绍 gonew。
安装 通过以下命令安装 gonew:
go install golang.org/x/tools/cmd/gonew@latest $ go install golang.org/x/tools/cmd/gonew@latest go: downloading golang.org/x/tools v0.12.0 go: downloading golang.org/x/mod v0.12.0 执行 gonew:
...</p></div><footer class=entry-footer><span title='2023-08-19 14:00:23 +0800 +0800'>八月 19, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to gonew 介绍" href=https://jasminides.com/posts/gonew%E7%AE%80%E4%BB%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ent 相同列名排序问题解决</h2></header><div class=entry-content><p>前言 最近在开发的时候，需要进行数据库计算，主要是根据表中的某些字段进行汇总计算，但由于数据库表中已有同名字段名，ent 不会使用计算后的指标，默认使用 schema 中定义的字段，导致无法返回正确的结果。
针对这种情况，我能想到的方法有 2 种：1) 不使用同名的字段名 2) 查找 ent 是否有相关的解决方案。
这里我采用了第二种方法，查找相关的 issues, 通过查找相关 issue，找到了相关的解决方案：ent 的 sql/modifier 特性。
场景重现 定义一个新的数据库表结构，结构如下：
func (Ad) Fields() []ent.Field { return []ent.Field{ field.Float("estimated_earnings"), field.Int("page_views"), field.Time("date"), field.Float("page_views_rpm").Optional(), } } page_views_rpm 字段是由 estimated_earnings 和 page_views 计算而来。
编写相应的查询代码：
package main import ( "context" "entgo.io/ent/dialect/sql" "fmt" _ "github.com/lib/pq" "log" "modifier-demo/ent" "modifier-demo/ent/ad" "time" ) type Ads struct { EstimatedEarnings float64 `json:"estimated_earnings"` PageViews int64 `json:"page_views"` Date time.Time `json:"date"` PageViewsRpm float64 `json:"page_views_rpm"` } func main() { client, err := ent.Open("postgres", "host=127.0.0.1 port=5432 sslmode=disable user=postgres dbname=data_test password=mysecretpassword") if err != nil { log.Fatalf("failed opening connection to postgres: %v", err) } defer client.Close() // Run the auto migration tool. if err := client.Schema.Create(context.Background()); err != nil { log.Fatalf("failed creating schema resources: %v", err) } var a []Ads err = client.Debug().Ad.Query().Order(ent.Desc(ad.FieldPageViewsRpm)).GroupBy(ad.FieldDate).Aggregate(func(selector *sql.Selector) string { return sql.As(" CAST(COALESCE(SUM(estimated_earnings) / NULLIF(SUM(page_views)*1.0, 0.0)*1000, 0)AS numeric(10,2))", "page_views_rpm") }).Scan(context.TODO(), &amp;a) if err != nil { return } fmt.Println(a) } 主要是根据 date 来汇总并重新计算 page_views_rpm 字段，运行代码后发现没有成功输出，打印后发现 ent 使用了旧的 PageViewsRpm 字段进行排序，导致 sql 无法顺利运行。
...</p></div><footer class=entry-footer><span title='2023-08-12 16:15:15 +0800 +0800'>八月 12, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to ent 相同列名排序问题解决" href=https://jasminides.com/posts/ent_sql_modifier/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Golang_embed 简单介绍</h2></header><div class=entry-content><p>最近需要使用 golang1.16 中的功能 embed ,本文简单记录下 embed 的使用。
embed 介绍 Go 1.16 引入了 embed 包，允许我们在编译时将静态文件（例如 .go、.html、.css、.js 等）嵌入到 Go 源文件中。这在构建静态网站、单页应用程序（SPA）和其他项目时非常有用。
主要有几个优点：
方便部署：不需要再部署静态资源文件，所有的资源都直接嵌入到可执行文件中。
安全：用户无法直接访问或修改嵌入的文件。
版本管理：和 Go 代码一起版本控制。
使用 嵌入为字符串 可以将文件内容保存到字符串变量中。
package main import ( _ "embed" "fmt" ) //go:embed hello.txt var s string func main() { fmt.Println(s) } 文件路径下有个 hello.txt，内容如下：hello, overstarry,代码运行输出：hello, overstarry
保存为 []bytes 还可以将文件内容保存为 []bytes 变量
package main import ( _ "embed" "fmt" ) //go:embed hello.txt var s []byte func main() { fmt.Println(string(s)) } 运行代码输出内容与上面一致。
...</p></div><footer class=entry-footer><span title='2023-08-05 17:37:56 +0800 +0800'>八月 5, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Golang_embed 简单介绍" href=https://jasminides.com/posts/golang_embed%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>rueidis 简介</h2></header><div class=entry-content><p>简介 rueidis 是一个快速的 Golang Redis 客户端，支持客户端缓存、Auto Pipelining、泛型 OM、RedisJSON、RedisBloom、RediSearch 等功能。
Features Auto pipelining for non-blocking redis commands RESP3 中的客户端缓存 Pub/Sub, Sharded Pub/Sub, Streams Redis Cluster, Sentinel, RedisJSON, RedisBloom, RediSearch, RedisTimeseries, 等。 具有客户端缓存和乐观锁定的通用对象映射 具有客户端缓存的分布式锁 rueidis mock OpenTelemetry 集成 Hooks and other 集成 提供类似 Go-redis API 的适配器 需要注意的是由于使用了一些 go1.20 版本才有的特性，如果想要使用低版本 go，必须安装相应的版本。
简单使用 package main import ( "context" "fmt" "github.com/redis/rueidis" ) func main() { // 创建 redis 客户端连接 client, err := rueidis.NewClient(rueidis.ClientOption{InitAddress: []string{"127.0.0.1:6379"}}) if err != nil { panic(err) } defer client.Close() ctx := context.Background() // 执行 redis set 命令 err = client.Do(ctx, client.B().Set().Key("key1").Value("val").Nx().Build()).Error() if err != nil { panic(err) } hm, err := client.Do(ctx, client.B().Get().Key("key1").Build()).ToString() if err != nil { panic(err) } fmt.Println(hm) } go-redis 适配器 如何快速从 go-redis 切换到 rueidis 客户端呢，rueidis 提供了 rueidiscompat.NewAdapter 方法，通过 Adapter 可以使用熟悉的 go-redis 中的方法。
...</p></div><footer class=entry-footer><span title='2023-07-08 15:43:01 +0800 +0800'>七月 8, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to rueidis 简介" href=https://jasminides.com/posts/rueidis%E7%AE%80%E4%BB%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Go wasi</h2></header><div class=entry-content><p>WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。
Go 从 1.11 版本就开始支持将 Go 源码编译为 wasm 二进制文件，并在支持 wasm 的浏览器环境中运行。
不过 WebAssembly 绝不仅仅被设计为仅限于在 Web 浏览器中运行，核心的 WebAssembly 语言是独立于其周围环境的，WebAssembly 完全可以通过 API 与外部世界互动。在 Web 上，它自然使用浏览器提供的现有 Web API。然而，在浏览器之外，之前还没有一套标准的 API 可以让 WebAssembly 程序使用。这使得创建真正可移植的非 Web WebAssembly 程序变得困难。WebAssembly System Interface(WASI) 是一个填补这一空白的倡议，它有一套干净的 API，可以由多个引擎在多个平台上实现，并且不依赖于浏览器的功能（尽管它们仍然可以在浏览器中运行）。
Go 1.21 将增加对 WASI 的支持，初期先支持 WASI Preview1 版本，之后会支持 WASI Preview2 版本，直至最终 WASI API 版本发布！
go 编译支持 wasi 的程序 怎么样才能编译支持 wasi 的程序呢？我们可以使用 GOOS=wasip1 GOARCH=wasm 将 Go 源码编译为支持 WASI 的 wasm 程序。下面是一个例子：
...</p></div><footer class=entry-footer><span title='2023-05-02 15:41:33 +0800 +0800'>五月 2, 2023</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go wasi" href=https://jasminides.com/posts/go-wasi/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>gRPC 服务反射协议</h2></header><div class=entry-content><p>本文主要介绍 gRPC 的服务反射协议和相关的应用。
介绍 gRPC 服务反射协议 (server reflection) 是在 gRPC 服务端定义的一个服务，它能提供该服务器端上可公开使用的 gRPC 服务的信息，简单的来说，就是服务反射向客户端提供了服务端注册的服务的信息。因此客户端不需要预编译服务定义就能与服务端交互了。
客户端想要与服务端程序进行通信，必须要有所定义的服务信息，需要编译生产客户端存根，借助 gRPC 服务反射协议，我们就可以无需编译服务定义就能通信。
使用 该如何开启服务反射协议呢？很简单，只需要通过一行代码即可开启：reflection.Register()
package main import ( "context" "flag" "fmt" "log" "net" "google.golang.org/grpc" "google.golang.org/grpc/reflection" ecpb "google.golang.org/grpc/examples/features/proto/echo" hwpb "google.golang.org/grpc/examples/helloworld/helloworld" ) var port = flag.Int("port", 50051, "the port to serve on") // hwServer is used to implement helloworld.GreeterServer. type hwServer struct { hwpb.UnimplementedGreeterServer } // SayHello implements helloworld.GreeterServer func (s *hwServer) SayHello(ctx context.Context, in *hwpb.HelloRequest) (*hwpb.HelloReply, error) { return &amp;hwpb.HelloReply{Message: "Hello " + in.Name}, nil } type ecServer struct { ecpb.UnimplementedEchoServer } func (s *ecServer) UnaryEcho(ctx context.Context, req *ecpb.EchoRequest) (*ecpb.EchoResponse, error) { return &amp;ecpb.EchoResponse{Message: req.Message}, nil } func main() { flag.Parse() lis, err := net.Listen("tcp", fmt.Sprintf(":%d", *port)) if err != nil { log.Fatalf("failed to listen: %v", err) } fmt.Printf("server listening at %v\n", lis.Addr()) s := grpc.NewServer() // Register Greeter on the server. hwpb.RegisterGreeterServer(s, &amp;hwServer{}) // Register RouteGuide on the same server. ecpb.RegisterEchoServer(s, &amp;ecServer{}) // Register reflection service on gRPC server. reflection.Register(s) if err := s.Serve(lis); err != nil { log.Fatalf("failed to serve: %v", err) } } 服务端开启服务反射协议后，就可以通过 gRPC CLI 工具来检查服务端了。这里就不多介绍了，接下来我们来看看服务反射协议在 kratos 中的使用。
...</p></div><footer class=entry-footer><span title='2022-08-27 23:50:09 +0800 +0800'>八月 27, 2022</span>&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to gRPC 服务反射协议" href=https://jasminides.com/posts/grpc_server_reflection/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jasminides.com/tags/go/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://jasminides.com/tags/go/page/3/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2024 - overstarry · All rights reserved<br></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>