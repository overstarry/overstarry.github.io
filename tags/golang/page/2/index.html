<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang | Overstarry Site</title><meta name=keywords content><meta name=description content="Overstarry 记录 AI 助理、MCP 集成与个人开发总结的 Hugo 博客"><meta name=author content="overstarry"><link rel=canonical href=https://jasminides.com/tags/golang/><meta name=google-site-verification content="gfdsdx"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=https://jasminides.com/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://jasminides.com/img/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jasminides.com/img/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jasminides.com/img/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://jasminides.com/img/favicon/apple-touch-icon.png><link rel=mask-icon href=https://jasminides.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jasminides.com/tags/golang/index.xml><link rel=alternate hreflang=zh href=https://jasminides.com/tags/golang/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-G40XG2SPQN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-G40XG2SPQN")}</script><meta property="og:url" content="https://jasminides.com/tags/golang/"><meta property="og:site_name" content="Overstarry Site"><meta property="og:title" content="Golang"><meta property="og:description" content="Overstarry 记录 AI 助理、MCP 集成与个人开发总结的 Hugo 博客"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://jasminides.com/img/generics1-fs8.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jasminides.com/img/generics1-fs8.png"><meta name=twitter:title content="Golang"><meta name=twitter:description content="Overstarry 记录 AI 助理、MCP 集成与个人开发总结的 Hugo 博客"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2240998016636586" crossorigin=anonymous></script><link rel=manifest href=https://jasminides.com/site.webmanifest></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jasminides.com/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jasminides.com/archives/ title=archives><span>archives</span></a></li><li><a href=https://jasminides.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://jasminides.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://jasminides.com/index.xml title=rss><span>rss</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://jasminides.com/>主页</a>&nbsp;»&nbsp;<a href=https://jasminides.com/tags/>Tags</a></div><h1>Golang</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>gonew 介绍</h2></header><div class=entry-content><p>前几周。在关注的 go 提案每周会议中，发现了一条比较感兴趣的内容：gonew: templates for new modules ,通过标题可以猜到 gonew 应该是一个通过配置项目模板生成新项目的模块。
通过对 discussions 中 rsc 所描述的内容进行分析，可以得知为什么要启动这么一个新项目: go 团队经常收到用户的请求，想要通过模板启动一个新项目，即以某种基本的项目模板来创建一个新 Go module。Russ 私下编写了一个实现这个功能的小工具:rsc.io/tmp/gonew. Russ 在 google 内部宣传该工具后，Google 内部的一些团队便定制了一些模板 (template) ，尤其是 ServiceWeaver 团队的响应尤为积极。这一切最终让 Russ 决定引入 golang.org/x/tools/cmd/gonew。 gonew 工具的引入大幅简化了 Go 项目的创建，同时由于对自定义项目模板的支持，也可以提高 Go 项目的标准化水平。目前 gonew 工具是实验性的，后续可能会增加新的特性，但目前的核心功能是会保留的。
通过对 discussions 中社区用户开发着的回应可以看出，大家纷纷讲述了没有 gonew 前所使用的工具，并对 gonew 建言献策，可以看出大部分的开发者都十分欢迎这个新功能的。
接下来就由我来介绍 gonew。
安装 通过以下命令安装 gonew:
go install golang.org/x/tools/cmd/gonew@latest $ go install golang.org/x/tools/cmd/gonew@latest go: downloading golang.org/x/tools v0.12.0 go: downloading golang.org/x/mod v0.12.0 执行 gonew:
...</p></div><footer class=entry-footer><span title='2023-08-19 14:00:23 +0800 +0800'>八月 19, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to gonew 介绍" href=https://jasminides.com/posts/gonew-%E4%BB%8B%E7%BB%8D/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Golang_embed 简单介绍</h2></header><div class=entry-content><p>最近需要使用 golang1.16 中的功能 embed ,本文简单记录下 embed 的使用。
embed 介绍 Go 1.16 引入了 embed 包，允许我们在编译时将静态文件（例如 .go、.html、.css、.js 等）嵌入到 Go 源文件中。这在构建静态网站、单页应用程序（SPA）和其他项目时非常有用。
主要有几个优点：
方便部署：不需要再部署静态资源文件，所有的资源都直接嵌入到可执行文件中。
安全：用户无法直接访问或修改嵌入的文件。
版本管理：和 Go 代码一起版本控制。
使用 嵌入为字符串 可以将文件内容保存到字符串变量中。
package main import ( _ "embed" "fmt" ) //go:embed hello.txt var s string func main() { fmt.Println(s) } 文件路径下有个 hello.txt，内容如下：hello, overstarry,代码运行输出：hello, overstarry
保存为 []bytes 还可以将文件内容保存为 []bytes 变量
package main import ( _ "embed" "fmt" ) //go:embed hello.txt var s []byte func main() { fmt.Println(string(s)) } 运行代码输出内容与上面一致。
...</p></div><footer class=entry-footer><span title='2023-08-05 17:37:56 +0800 +0800'>八月 5, 2023</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Golang_embed 简单介绍" href=https://jasminides.com/posts/golang_embed-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>rueidis 简介</h2></header><div class=entry-content><p>简介 rueidis 是一个快速的 Golang Redis 客户端，支持客户端缓存、Auto Pipelining、泛型 OM、RedisJSON、RedisBloom、RediSearch 等功能。
Features Auto pipelining for non-blocking redis commands RESP3 中的客户端缓存 Pub/Sub, Sharded Pub/Sub, Streams Redis Cluster, Sentinel, RedisJSON, RedisBloom, RediSearch, RedisTimeseries, 等。 具有客户端缓存和乐观锁定的通用对象映射 具有客户端缓存的分布式锁 rueidis mock OpenTelemetry 集成 Hooks and other 集成 提供类似 Go-redis API 的适配器 需要注意的是由于使用了一些 go1.20 版本才有的特性，如果想要使用低版本 go，必须安装相应的版本。
简单使用 package main import ( "context" "fmt" "github.com/redis/rueidis" ) func main() { // 创建 redis 客户端连接 client, err := rueidis.NewClient(rueidis.ClientOption{InitAddress: []string{"127.0.0.1:6379"}}) if err != nil { panic(err) } defer client.Close() ctx := context.Background() // 执行 redis set 命令 err = client.Do(ctx, client.B().Set().Key("key1").Value("val").Nx().Build()).Error() if err != nil { panic(err) } hm, err := client.Do(ctx, client.B().Get().Key("key1").Build()).ToString() if err != nil { panic(err) } fmt.Println(hm) } go-redis 适配器 如何快速从 go-redis 切换到 rueidis 客户端呢，rueidis 提供了 rueidiscompat.NewAdapter 方法，通过 Adapter 可以使用熟悉的 go-redis 中的方法。
...</p></div><footer class=entry-footer><span title='2023-07-08 15:43:01 +0800 +0800'>七月 8, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to rueidis 简介" href=https://jasminides.com/posts/rueidis-%E7%AE%80%E4%BB%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Go 实现简单反向代理</h2></header><div class=entry-content><p>前言 说起反向代理，大家应该都不陌生，是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。常见的反向代理有 Nginx,HAProxy,Apisix 等。
接下来介绍如何使用 go 实现一个反向代理服务器。
golang 实现 使用 golang 实现反向代理非常简单，标准库 net/http/httputil 提供了反向代理的方法可以让我们方便的实现反向代理，使我们可以很快的实现一个简单的反向代理服务器。
package main import ( "log" "net/http" "net/http/httputil" "net/url" ) func NewProxy(targetHost string) (*httputil.ReverseProxy, error) { url, err := url.Parse(targetHost) if err != nil { return nil, err } return httputil.NewSingleHostReverseProxy(url), nil } func ProxyRequestHandler(proxy *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) { return func(w http.ResponseWriter, r *http.Request) { proxy.ServeHTTP(w, r) } } func main() { proxy, err := NewProxy("https://overstarry.vip") if err != nil { panic(err) } http.HandleFunc("/", ProxyRequestHandler(proxy)) log.Fatal(http.ListenAndServe(":8080", nil)) } 这段代码将到达我们代理服务器的任何请求都会被代理到 https://overstarry.vip。我们运行代码，访问网站，发现 403 Forbidden 好像请求被拦截了，应该是源网站进行了请求校验，这该怎么处理呢？通过查阅资料得知，我们需要将 host 传递过去，修改后的代码如下：
package main import ( "log" "net/http" "net/http/httputil" "net/url" ) func NewProxy(targetHost string) (*httputil.ReverseProxy, error) { url, err := url.Parse(targetHost) if err != nil { return nil, err } return httputil.NewSingleHostReverseProxy(url), nil } func ProxyRequestHandler(proxy *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) { return func(w http.ResponseWriter, r *http.Request) { r.Host = "overstarry.vip" proxy.ServeHTTP(w, r) } } func main() { proxy, err := NewProxy("https://overstarry.vip") if err != nil { panic(err) } http.HandleFunc("/", ProxyRequestHandler(proxy)) log.Fatal(http.ListenAndServe(":8080", nil)) } 现在运行代码即可正常访问了。
...</p></div><footer class=entry-footer><span title='2023-04-08 17:12:41 +0800 +0800'>四月 8, 2023</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 实现简单反向代理" href=https://jasminides.com/posts/go-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Go 时间处理库 carbon</h2></header><div class=entry-content><p>我们在日常开发中，常常会对时间进行各种处理，今天我来介绍一个 go 处理时间的库 golang-module/carbon。
Carbon 是一个轻量级、语义化、对开发者友好的 golang 时间处理库，支持链式调用。
安装 go 版本大于 1.16
go get -u github.com/golang-module/carbon/v2 版本小于 1.16
go get -u github.com/golang-module/carbon 使用 创建 carbon 实例 carbon.Now() // 获取当前时间 carbon.Now("Asia/Qatar").ToDateTimeString() // 不同时区当前的时间，卡塔尔当前的时间 carbon.Yesterday() // 昨天 carbon.CreateFromTime(22, 9, 13).ToString() carbon.Tomorrow().ToDateString() // 明天 标准库转换 carbon 还可以和标准库 time 进行相互转换。
// 将 标准库 time 转换为 carbon 实例 carbon.Time2Carbon(time.Now()) // carbon 转换为 time.Time 解析字符串 carbon 可以解析字符串，生成 carbon 实例
// 将时间字符串转换为 carbon 实例 fmt.Println(carbon.Parse("1998-04-01").ToDateTimeString()) carbon.Parse("tomorrow").ToString() carbon.ParseByFormat("2020|08|05 13|14|15", "Y|m|d H|i|s").ToDateTimeString() // 2020-08-05 13:14:15 carbon.ParseByFormat("It is 2020-08-05 13:14:15", "\\I\\t \\i\\s Y-m-d H:i:s").ToDateTimeString() // 2020-08-05 13:14:15 carbon.ParseByFormat("今天是 2020 年 08 月 05 日 13 时 14 分 15 秒", "今天是 Y 年 m 月 d 日 H 时 i 分 s 秒").ToDateTimeString() // 2020-08-05 13:14:15 carbon.ParseByFormat("2020-08-05 13:14:15", "Y-m-d H:i:s", carbon.Tokyo).ToDateTimeString() // 2020-08-05 14:14:15 获取开始时间和结束时间 carbon 可以很方便的获取一个时刻的开始和结束
...</p></div><footer class=entry-footer><span title='2022-12-03 22:33:35 +0800 +0800'>十二月 3, 2022</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 时间处理库 carbon" href=https://jasminides.com/posts/go-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%BA%93-carbon/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fly.io 部署 go 应用</h2></header><div class=entry-content><p>前面讲解了 Fly.io 的初步入门使用，本文讲解在没有 docker 环境情况下部署 go 开发的应用。
项目 这里为了演示方便，简单使用 go 编写一个：
package main import ( "fmt" "log" "net/http" ) func main() { http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w,"hello world") }) log.Println("listening on", 8080) log.Fatal(http.ListenAndServe(":"+"8080", nil)) } 安装 Flyctl 并登录 这个步骤上篇文章已经介绍过来，还不了解如何安装登录的可以参考前面的文章。
配置 Fly 应用程序 进入项目的根目录，执行 flyctl launch,它会根据你输入的配置 (主要是应用名，部署区域，是否需要数据库和 redis) 来生成相应的配置文件，并帮你在远程构建器上打包镜像并部署，如果有 DOCKERFILE 文件就会使用你的进行构建，如果没有就会使用相应的官方文件进行构建镜像。
需要注意的是你的应用需要监听 8080 端口，否则部署时会报错
从日志可以看到打包好的镜像名是 registry.fly.io/cool-grass-2591:deployment-01GHPEDCXBC3K5NAGHNZWKT49H
fly.toml 配置 我们来看看 flyctl 帮我们生成的 fly.toml 具体内容：
# fly.toml file generated for cool-grass-2591 on 2022-11-13T01:32:35+08:00 app = "cool-grass-2591" kill_signal = "SIGINT" kill_timeout = 5 processes = [] [env] [experimental] allowed_public_ports = [] auto_rollback = true [[services]] http_checks = [] internal_port = 8080 processes = ["app"] protocol = "tcp" script_checks = [] [services.concurrency] hard_limit = 25 soft_limit = 20 type = "connections" [[services.ports]] force_https = true handlers = ["http"] port = 80 [[services.ports]] handlers = ["tls", "http"] port = 443 [[services.tcp_checks]] grace_period = "1s" interval = "15s" restart_limit = 0 timeout = "2s" 主要就是一些常规的服务端口配置等。
...</p></div><footer class=entry-footer><span title='2022-11-12 21:58:19 +0800 +0800'>十一月 12, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Fly.io 部署 go 应用" href=https://jasminides.com/posts/fly.io-%E9%83%A8%E7%BD%B2-go-%E5%BA%94%E7%94%A8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>前后端使用 AES 加密传输数据</h2></header><div class=entry-content><p>最近遇到前后端传输数据需要进行加密的需求，本篇文章就分别介绍使用 Node.js 和 go 进行 AES 加密解密的方法，AES 有很多不同的算法，如 aes192，aes-128-ecb，aes-256-cbc 等，根据不同的密钥长度会使用不同的算法。加密后的结果有两种表示方法：hex 和 base64，我们这里使用 hex.
golang 使用 golang 实现 aes 加密，我使用标准库的方法实现，我使用的 CBC 模式。
加密 func AesEncrypt(encryptStr string, key []byte, iv string) (string, error) { encryptBytes := []byte(encryptStr) block, err := aes.NewCipher(key) if err != nil { return "", err } blockSize := block.BlockSize() encryptBytes = pkcs5Padding(encryptBytes, blockSize) blockMode := cipher.NewCBCEncrypter(block, []byte(iv)) encrypted := make([]byte, len(encryptBytes)) blockMode.CryptBlocks(encrypted, encryptBytes) return hex.EncodeToString(encrypted), nil } 解密 func AesDecrypt(decryptStr string, key []byte, iv string) (string, error) { decryptBytes, err := hex.DecodeString(decryptStr) if err != nil { return "", err } block, err := aes.NewCipher(key) if err != nil { return "", err } blockMode := cipher.NewCBCDecrypter(block, []byte(iv)) decrypted := make([]byte, len(decryptBytes)) blockMode.CryptBlocks(decrypted, decryptBytes) decrypted = pkcs5UnPadding(decrypted) return string(decrypted), nil } 运行加密解密例子 package main import ( "bytes" "crypto/aes" "crypto/cipher" "encoding/hex" "fmt" ) func AesEncrypt(encryptStr string, key []byte, iv string) (string, error) { encryptBytes := []byte(encryptStr) block, err := aes.NewCipher(key) if err != nil { return "", err } blockSize := block.BlockSize() encryptBytes = pkcs5Padding(encryptBytes, blockSize) blockMode := cipher.NewCBCEncrypter(block, []byte(iv)) encrypted := make([]byte, len(encryptBytes)) blockMode.CryptBlocks(encrypted, encryptBytes) return hex.EncodeToString(encrypted), nil } func AesDecrypt(decryptStr string, key []byte, iv string) (string, error) { decryptBytes, err := hex.DecodeString(decryptStr) if err != nil { return "", err } block, err := aes.NewCipher(key) if err != nil { return "", err } blockMode := cipher.NewCBCDecrypter(block, []byte(iv)) decrypted := make([]byte, len(decryptBytes)) blockMode.CryptBlocks(decrypted, decryptBytes) decrypted = pkcs5UnPadding(decrypted) return string(decrypted), nil } func pkcs5Padding(cipherText []byte, blockSize int) []byte { padding := blockSize - len(cipherText)%blockSize padText := bytes.Repeat([]byte{byte(padding)}, padding) return append(cipherText, padText...) } func pkcs5UnPadding(decrypted []byte) []byte { length := len(decrypted) unPadding := int(decrypted[length-1]) return decrypted[:(length - unPadding)] } func main() { data := "i am test data" key := []byte("1111111111111111") iv := "1111122211111111" encrypt, err := AesEncrypt(data, key, iv) if err != nil { panic(err) return } fmt.Println(encrypt) decrypt, err := AesDecrypt(encrypt, key, iv) if err != nil { panic(err) } fmt.Println(decrypt) } ...</p></div><footer class=entry-footer><span title='2022-10-29 16:28:17 +0800 +0800'>十月 29, 2022</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to 前后端使用 AES 加密传输数据" href=https://jasminides.com/posts/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BD%BF%E7%94%A8-aes-%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>gRPC 服务反射协议</h2></header><div class=entry-content><p>本文主要介绍 gRPC 的服务反射协议和相关的应用。
介绍 gRPC 服务反射协议 (server reflection) 是在 gRPC 服务端定义的一个服务，它能提供该服务器端上可公开使用的 gRPC 服务的信息，简单的来说，就是服务反射向客户端提供了服务端注册的服务的信息。因此客户端不需要预编译服务定义就能与服务端交互了。
客户端想要与服务端程序进行通信，必须要有所定义的服务信息，需要编译生产客户端存根，借助 gRPC 服务反射协议，我们就可以无需编译服务定义就能通信。
使用 该如何开启服务反射协议呢？很简单，只需要通过一行代码即可开启：reflection.Register()
package main import ( "context" "flag" "fmt" "log" "net" "google.golang.org/grpc" "google.golang.org/grpc/reflection" ecpb "google.golang.org/grpc/examples/features/proto/echo" hwpb "google.golang.org/grpc/examples/helloworld/helloworld" ) var port = flag.Int("port", 50051, "the port to serve on") // hwServer is used to implement helloworld.GreeterServer. type hwServer struct { hwpb.UnimplementedGreeterServer } // SayHello implements helloworld.GreeterServer func (s *hwServer) SayHello(ctx context.Context, in *hwpb.HelloRequest) (*hwpb.HelloReply, error) { return &amp;hwpb.HelloReply{Message: "Hello " + in.Name}, nil } type ecServer struct { ecpb.UnimplementedEchoServer } func (s *ecServer) UnaryEcho(ctx context.Context, req *ecpb.EchoRequest) (*ecpb.EchoResponse, error) { return &amp;ecpb.EchoResponse{Message: req.Message}, nil } func main() { flag.Parse() lis, err := net.Listen("tcp", fmt.Sprintf(":%d", *port)) if err != nil { log.Fatalf("failed to listen: %v", err) } fmt.Printf("server listening at %v\n", lis.Addr()) s := grpc.NewServer() // Register Greeter on the server. hwpb.RegisterGreeterServer(s, &amp;hwServer{}) // Register RouteGuide on the same server. ecpb.RegisterEchoServer(s, &amp;ecServer{}) // Register reflection service on gRPC server. reflection.Register(s) if err := s.Serve(lis); err != nil { log.Fatalf("failed to serve: %v", err) } } 服务端开启服务反射协议后，就可以通过 gRPC CLI 工具来检查服务端了。这里就不多介绍了，接下来我们来看看服务反射协议在 kratos 中的使用。
...</p></div><footer class=entry-footer><span title='2022-08-27 23:50:09 +0800 +0800'>八月 27, 2022</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to gRPC 服务反射协议" href=https://jasminides.com/posts/grpc-%E6%9C%8D%E5%8A%A1%E5%8F%8D%E5%B0%84%E5%8D%8F%E8%AE%AE/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Go 发送邮件</h2></header><div class=entry-content><p>介绍 电子邮件是一种用电子手段提供信息交换的通信方式，是互联网应用最广的服务。通过网络的电子邮件系统，用户可以以非常低廉的价格（不管发送到哪里，都只需负担网费）、非常快速的方式（几秒钟之内可以发送到世界上任何指定的目的地），与世界上任何一个角落的网络用户联系。
电子邮件在网络中的传输需要遵从一定的协议的，常用的电子邮件协议包括 SMTP，POP3，IMAP。电子邮件的创建和发送只涉及到 SMTP 协议，本文主要就是介绍 go 使用 SMTP 协议发生邮件。
使用 我们这里使用 https://github.com/jordan-wright/email 这个 pkg 来创建和发送邮件。pkg 的安装这里就不过多介绍了。
我们知道邮箱使用 SMTP/POP3/IMAP 等协议从邮件服务器上拉取邮件。邮件并不是直接发送到邮箱的，而是邮箱请求拉取的。所以，我们需要配置 SMTP/POP3/IMAP 服务器。从头搭建固然可行，而且也有现成的开源库，但是比较麻烦。这里我使用 gmail，配置流程就不过多介绍了 (ps: Google 的安全性还是比较强的，设置了好久。
代码：
package main import ( "log" "net/smtp" "github.com/jordan-wright/email" ) func main() { e := email.NewEmail() e.From = "jm@gmail.com" e.To = []string{"1@qq.com"} e.Subject = "这是主题" e.Text = []byte("测试邮件发送") err := e.Send("smtp.gmail.com:587", smtp.PlainAuth("", "jm@gmail.com", "xx", "smtp.gmail.com")) if err != nil { log.Fatal(err) } } 过一会就顺利收到邮件了，有时候邮件会被当作垃圾邮件收入垃圾箱里，收不到时可以去垃圾箱看看。
参考 https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/111106</p></div><footer class=entry-footer><span title='2022-07-16 20:47:01 +0800 +0800'>七月 16, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 发送邮件" href=https://jasminides.com/posts/go-%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Go 模糊测试</h2></header><div class=entry-content><p>本篇文章主要讲解在 go 语言中进行模糊测试的基础知识。通过模糊测试，随机数据会针对您的测试运行，以尝试找出漏洞或导致崩溃的输入。可以通过模糊测试发现的一些漏洞示例包括 SQL 注入、buffer overflow、拒绝服务和 cross-site scripting 攻击。
想要在 go 中使用模糊测试，需要安装 go1.18beta1 以上版本，具体的安装就不过多叙述了。
1 创建项目文件夹
我们创建一个名叫 fuzz-demo 的文件夹，并在其中创建一个名叫 main.go 的文件。
2 输入代码
在 main.go 中输入如下代码：
package main import "fmt" func Reverse(s string) string { b := []byte(s) for i, j := 0, len(b)-1; i &lt; len(b)/2; i, j = i+1, j-1 { b[i], b[j] = b[j], b[i] } return string(b) } func main() { input := "quick quick brown fox jumped over the lazy dog" rev := Reverse(input) doubleRev := Reverse(rev) fmt.Printf("原来: %q\n", input) fmt.Printf("反转: %q\n", rev) fmt.Printf("再反转: %q\n", doubleRev) } Reverse 函数的作用就是对字符串进行反转。
...</p></div><footer class=entry-footer><span title='2022-03-06 10:47:15 +0800 +0800'>三月 6, 2022</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;overstarry</footer><a class=entry-link aria-label="post link to Go 模糊测试" href=https://jasminides.com/posts/go-%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jasminides.com/tags/golang/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://jasminides.com/tags/golang/page/3/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Copyright © 2024-now - overstarry · All rights reserved<br></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script type=text/javascript src=//pl27931222.effectivegatecpm.com/4d/7d/1b/4d7d1bf61b7acfe9e844e445ec09d596.js></script></body></html>